# Conversation: 86853493-a694-4104-8dc5-2b5ee14cd57a
**Session ID:** 86853493-a694-4104-8dc5-2b5ee14cd57a
**Started:** 2026-02-05T18:31:05.774Z
**Messages:** 10
**Exported:** 2026-02-05T18:35:01.664Z

---

### üë§ **User** [18:31:05]

[Thu 2026-02-05 18:31 UTC] Implement a full i18n (internationalization) system for the Lightning Telegram Bot at `/home/neo/lightning-telegram-bot/bot.js` (3170 lines).

## Step 1: Create the i18n module

Create `/home/neo/lightning-telegram-bot/i18n.js`:

```javascript
import fs from 'fs';
import { dirname, join } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const locales = {};
const SUPPORTED = ['es', 'en', 'pt', 'ru'];
const DEFAULT_LOCALE = 'es';

// Load all locale files
for (const lang of SUPPORTED) {
  const path = join(__dirname, 'locales', `${lang}.json`);
  if (fs.existsSync(path)) {
    locales[lang] = JSON.parse(fs.readFileSync(path, 'utf-8'));
  }
}

/**
 * Translate a key with parameter substitution
 * @param {string} locale - Language code
 * @param {string} key - Translation key
 * @param {object} params - Parameters to substitute {key} patterns
 * @returns {string}
 */
export function t(locale, key, params = {}) {
  const str = locales[locale]?.[key] || locales[DEFAULT_LOCALE]?.[key] || key;
  return str.replace(/\{(\w+)\}/g, (_, k) => params[k] !== undefined ? params[k] : `{${k}}`);
}

export function getSupportedLocales() { return SUPPORTED; }
export function isSupported(locale) { return SUPPORTED.includes(locale); }
export { DEFAULT_LOCALE };
```

## Step 2: Add locale column to users table

In bot.js, add migration after the existing role migration:
```javascript
try {
  db.exec("ALTER TABLE users ADD COLUMN locale TEXT DEFAULT 'es'");
} catch (e) { /* Column already exists */ }
```

Add a helper function:
```javascript
function getUserLocale(telegramId) {
  const user = db.prepare('SELECT locale FROM users WHERE telegram_id = ?').get(telegramId);
  return user?.locale || 'es';
}
```

## Step 3: Create the Spanish locale file

Read through ALL of bot.js carefully and extract EVERY user-facing string into translation keys. Create `/home/neo/lightning-telegram-bot/locales/es.json` with ALL strings.

Use descriptive UPPER_SNAKE_CASE keys like:
- WELCOME, WELCOME_COMMANDS, BALANCE_MSG, RECEIVE_USAGE, RECEIVE_MAX_ERROR
- PAY_DECODE_INFO, PAY_CONFIRM_BTN, PAY_SUCCESS, PAY_INSUFFICIENT
- GIVEAWAY_MSG, GIVEAWAY_CLAIMED, GIVEAWAY_EXPIRED
- COINFLIP_CREATED, COINFLIP_JOINED, COINFLIP_WINNER
- RATE_LIMIT, ADMIN_ONLY, OWNER_ONLY, DM_SENT, etc.

For multi-line messages (like /start welcome, /help text), use `\n` in the JSON string.

Use `{param}` syntax for dynamic values:
- `{amount}` for sats amounts
- `{user}` for usernames  
- `{fee}` for fees
- `{balance}` for balances
- etc.

## Step 4: Create English translation

Create `/home/neo/lightning-telegram-bot/locales/en.json` with English translations of ALL keys.

## Step 5: Create Portuguese translation

Create `/home/neo/lightning-telegram-bot/locales/pt.json` with Brazilian Portuguese translations.

## Step 6: Create Russian translation

Create `/home/neo/lightning-telegram-bot/locales/ru.json` with Russian translations.

## Step 7: Add /language command to bot.js

```javascript
bot.onText(/\/language(?:\s+(\w+))?/, async (msg, match) => {
  const userId = msg.from.id;
  const locale = match[1]?.toLowerCase();
  
  if (!locale) {
    // Show available languages with current selection
    const current = getUserLocale(userId);
    const langs = [
      { code: 'es', flag: 'üá™üá∏', name: 'Espa√±ol' },
      { code: 'en', flag: 'üá¨üáß', name: 'English' },
      { code: 'pt', flag: 'üáßüá∑', name: 'Portugu√™s' },
      { code: 'ru', flag: 'üá∑üá∫', name: '–†—É—Å—Å–∫–∏–π' }
    ];
    // Show inline keyboard with language buttons
    const buttons = langs.map(l => [{
      text: `${l.flag} ${l.name}${l.code === current ? ' ‚úì' : ''}`,
      callback_data: `lang_${l.code}`
    }]);
    await bot.sendMessage(msg.chat.id, t(current, 'LANGUAGE_SELECT'), {
      reply_markup: { inline_keyboard: buttons }
    });
    return;
  }
  
  if (!isSupported(locale)) {
    await bot.sendMessage(msg.chat.id, t(getUserLocale(userId), 'LANGUAGE_UNSUPPORTED', { lang: locale }));
    return;
  }
  
  db.prepare('UPDATE users SET locale = ? WHERE telegram_id = ?').run(locale, userId);
  await bot.sendMessage(msg.chat.id, t(locale, 'LANGUAGE_CHANGED'));
});
```

Also add `lang_` callback handling in the callback_query handler.

## Step 8: Replace ALL hardcoded strings in bot.js

This is the biggest step. Go through EVERY sendMessage call and replace the hardcoded string with `t(getUserLocale(userId), 'KEY', { params })`.

For group messages, use the sender's locale. For DM messages, use the recipient's locale.

Pattern:
```javascript
// BEFORE:
await bot.sendMessage(chatId, '‚ùå Saldo insuficiente');

// AFTER:
await bot.sendMessage(chatId, t(getUserLocale(msg.from.id), 'INSUFFICIENT_BALANCE'));
```

For the /help and /start messages which are long multi-line strings, use a single key with the full text.

IMPORTANT: Import the i18n module at the top of bot.js:
```javascript
import { t, getSupportedLocales, isSupported, DEFAULT_LOCALE } from './i18n.js';
```

## Step 9: Verify and deploy

1. Run `node -c bot.js` to check syntax
2. Run `node -c i18n.js` to check i18n module
3. Verify all 4 locale JSON files are valid: `node -e "JSON.parse(require('fs').readFileSync('locales/es.json'))"` (for each)
4. Run `cd /home/neo/lightning-telegram-bot && git add -A && git commit -m "feat: i18n system with 4 languages (es/en/pt/ru)"`
5. Restart: `systemctl --user restart lightning-bot.service`
6. Verify: `systemctl --user status lightning-bot.service | head -10`
7. Check for errors: `tail -10 bot.log`

## CRITICAL NOTES:
- Read the ENTIRE bot.js first before making changes
- Do NOT miss any string ‚Äî check every sendMessage, sendPhoto caption
- Keep the Markdown parse_mode on messages that use it
- The escMd() function must still be applied to dynamic content INSIDE translation parameters, not to the template itself
- For messages that contain Markdown formatting (* for bold, _ for italic), include the formatting in the locale files
- Test that the JSON files are valid (no trailing commas, proper escaping of quotes)
- Buttons text (inline_keyboard) should also be translated where user-facing
- Error messages should be translated too
- The /help command builds a long message - put it in the locale file as a single key with \n
- Some messages are constructed dynamically (like /history, /stats) - these need t() calls for the labels while keeping dynamic data

Take your time, be thorough. This is a big refactor.

---

### ü§ñ **Claudio** [18:31:12]

I'll implement this comprehensive i18n system step by step. This is a significant refactor, so I'll be thorough and methodical.

## Step 1: Reading bot.js to understand the structure

---

### ü§ñ **Claudio** [18:31:12]

#!/usr/bin/env node
/**
 * Lightning Telegram Bot - Simple Custodial Wallet
 * Direct LND integration without LNbits
 */

import TelegramBot from 'node-telegram-bot-api';
import Database from 'better-sqlite3';
import fs from 'fs';
import https from 'https';
import QRCode from 'qrcode';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import { config as dotenvConfig } from 'dotenv';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Load .env file
dotenvConfig({ path: join(__dirname, '.env') });

// Configuration ‚Äî from environment variables (fallback to hardcoded for backward compat)
const BOT_TOKEN = process.env.BOT_TOKEN || '[BOT_TOKEN_REDACTED]';
const LND_REST_HOST = process.env.LND_REST_HOST || '127.0.0.1:8081';
const LND_MACAROON = fs.readFileSync(process.env.LND_MACAROON_PATH || '/home/neo/.lnd/data/chain/bitcoin/mainnet/admin.macaroon').toString('hex');
const LND_TLS_CERT = fs.readFileSync(process.env.LND_TLS_CERT_PATH || '/home/neo/.lnd/tls.cert');

// Fee configuration (in basis points, 100 = 1%)
const FEE_INTERNAL_TRANSFER = 50;  // 0.5%
const FEE_WITHDRAWAL = 100;         // 1%
const FEE_DEPOSIT = 0;              // 0% (free deposits)

// Group join ticket configuration
const GROUP_JOIN_TICKET_SATS = 1000;  // Cost to join a group
const GROUP_JOIN_TIMEOUT_SECONDS = 3600;  // 1 hour to pay

// Initialize bot
const bot = new TelegramBot(BOT_TOKEN, { polling: true });

// === RATE LIMITING ===
const rateLimits = new Map(); // userId -> { count, resetAt }
const RATE_LIMIT_WINDOW_MS = 60_000; // 1 minute
const RATE_LIMIT_MAX = 15; // max commands per minute (generous for normal use, blocks spam)
const RATE_LIMIT_FINANCIAL_MAX = 5; // max financial commands (send/tip) per minute

function checkRateLimit(userId, isFinancial = false) {
  const now = Date.now();
  const key = isFinancial ? `fin:${userId}` : `cmd:${userId}`;
  const limit = isFinancial ? RATE_LIMIT_FINANCIAL_MAX : RATE_LIMIT_MAX;
  
  let entry = rateLimits.get(key);
  if (!entry || now > entry.resetAt) {
    entry = { count: 0, resetAt: now + RATE_LIMIT_WINDOW_MS };
    rateLimits.set(key, entry);
  }
  
  entry.count++;
  if (entry.count > limit) {
    return false; // rate limited
  }
  return true;
}

// Cleanup stale rate limit entries every 5 minutes
setInterval(() => {
  const now = Date.now();
  for (const [key, entry] of rateLimits) {
    if (now > entry.resetAt) rateLimits.delete(key);
  }
}, 300_000);

// === STRUCTURED LOGGING SYSTEM ===
const LOG_FILE = join(__dirname, 'activity.log');

function logActivity(event, userId, username, details = {}) {
  const entry = {
    ts: new Date().toISOString(),
    event,
    user_id: userId || null,
    username: username || null,
    ...details
  };
  const line = JSON.stringify(entry);
  
  // Write to activity log file
  fs.appendFileSync(LOG_FILE, line + '\n');
  
  // Also console for bot.log
  const detailStr = Object.entries(details)
    .filter(([k]) => !['user_id', 'username'].includes(k))
    .map(([k, v]) => `${k}=${v}`)
    .join(' ');
  console.log(`[${entry.ts}] ${event} | user=${username || userId} | ${detailStr}`);
}

// Log all incoming messages
bot.on('message', (msg) => {
  const text = msg.text || '(no text)';
  const isCommand = text.startsWith('/');
  logActivity(isCommand ? 'COMMAND' : 'MESSAGE', msg.from?.id, msg.from?.username, {
    chat_id: msg.chat.id,
    chat_type: msg.chat.type,
    text: text.substring(0, 100)
  });
  
  if (msg.new_chat_members && msg.new_chat_members.length > 0) {
    logActivity('NEW_MEMBERS_IN_MSG', msg.from?.id, msg.from?.username, {
      chat_id: msg.chat.id,
      members: msg.new_chat_members.map(m => m.id).join(',')
    });
  }
});

// Initialize database
const db = new Database(join(__dirname, 'bot.db'));

// User roles
const ROLE_OWNER = 'owner';     // Daniel - full access
const ROLE_OPERATOR = 'operator'; // Claudio (me) - operational access
const ROLE_ADMIN = 'admin';     // Group admins - group management
const ROLE_USER = 'user';       // Regular users

// Owner and operator IDs
const OWNER_ID = 140223355; // Daniel

// Create tables
db.exec(`
  CREATE TABLE IF NOT EXISTS users (
    telegram_id INTEGER PRIMARY KEY,
    username TEXT,
    balance_sats INTEGER DEFAULT 0,
    role TEXT DEFAULT 'user',
    created_at INTEGER DEFAULT (strftime('%s', 'now'))
  );

  CREATE TABLE IF NOT EXISTS transactions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    telegram_id INTEGER,
    type TEXT,
    amount_sats INTEGER,
    fee_sats INTEGER DEFAULT 0,
    description TEXT,
    payment_hash TEXT,
    created_at INTEGER DEFAULT (strftime('%s', 'now')),
    FOREIGN KEY (telegram_id) REFERENCES users(telegram_id)
  );

  CREATE TABLE IF NOT EXISTS pending_invoices (
    payment_hash TEXT PRIMARY KEY,
    telegram_id INTEGER,
    amount_sats INTEGER,
    created_at INTEGER DEFAULT (strftime('%s', 'now')),
    FOREIGN KEY (telegram_id) REFERENCES users(telegram_id)
  );

  CREATE TABLE IF NOT EXISTS group_join_requests (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    telegram_id INTEGER,
    chat_id INTEGER,
    payment_hash TEXT,
    amount_sats INTEGER,
    status TEXT DEFAULT 'pending',
    created_at INTEGER DEFAULT (strftime('%s', 'now')),
    FOREIGN KEY (telegram_id) REFERENCES users(telegram_id)
  );

  CREATE TABLE IF NOT EXISTS group_configs (
    chat_id INTEGER PRIMARY KEY,
    owner_telegram_id INTEGER NOT NULL,
    title TEXT,
    ticket_price_sats INTEGER DEFAULT 1000,
    enabled INTEGER DEFAULT 1,
    created_at INTEGER DEFAULT (strftime('%s', 'now')),
    updated_at INTEGER DEFAULT (strftime('%s', 'now')),
    FOREIGN KEY (owner_telegram_id) REFERENCES users(telegram_id)
  );

  CREATE TABLE IF NOT EXISTS giveaways (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    message_id INTEGER,
    chat_id INTEGER,
    giver_telegram_id INTEGER,
    amount_sats INTEGER,
    claimer_telegram_id INTEGER,
    status TEXT DEFAULT 'active',
    created_at INTEGER DEFAULT (strftime('%s', 'now')),
    expires_at INTEGER
  );

  CREATE TABLE IF NOT EXISTS giveflips (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    message_id INTEGER,
    chat_id INTEGER,
    giver_telegram_id INTEGER,
    amount_sats INTEGER,
    max_participants INTEGER DEFAULT 2,
    winner_telegram_id INTEGER,
    status TEXT DEFAULT 'active',
    created_at INTEGER DEFAULT (strftime('%s', 'now')),
    expires_at INTEGER
  );

  CREATE TABLE IF NOT EXISTS giveflip_participants (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    giveflip_id INTEGER,
    telegram_id INTEGER,
    FOREIGN KEY (giveflip_id) REFERENCES giveflips(id)
  );

  CREATE TABLE IF NOT EXISTS fundraises (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    message_id INTEGER,
    chat_id INTEGER,
    creator_telegram_id INTEGER,
    recipient_telegram_id INTEGER,
    recipient_username TEXT,
    amount_per_person INTEGER,
    max_participants INTEGER,
    status TEXT DEFAULT 'active',
    created_at INTEGER DEFAULT (strftime('%s', 'now')),
    expires_at INTEGER
  );

  CREATE TABLE IF NOT EXISTS fundraise_contributors (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    fundraise_id INTEGER,
    telegram_id INTEGER,
    FOREIGN KEY (fundraise_id) REFERENCES fundraises(id)
  );
`);

// Migration: add role column if it doesn't exist
try {
  db.exec("ALTER TABLE users ADD COLUMN role TEXT DEFAULT 'user'");
} catch (e) {
  // Column already exists
}

// Set owner role for Daniel
db.prepare("UPDATE users SET role = ? WHERE telegram_id = ?").run(ROLE_OWNER, OWNER_ID);

// Authorization helpers
function isOwner(telegramId) { return telegramId === OWNER_ID; }
function isOperator(telegramId) {
  const user = db.prepare('SELECT role FROM users WHERE telegram_id = ?').get(telegramId);
  return user && (user.role === ROLE_OPERATOR || user.role === ROLE_OWNER);
}
function isAdminOrAbove(telegramId) {
  const user = db.prepare('SELECT role FROM users WHERE telegram_id = ?').get(telegramId);
  return user && [ROLE_ADMIN, ROLE_OPERATOR, ROLE_OWNER].includes(user.role);
}
function getUserRole(telegramId) {
  const user = db.prepare('SELECT role FROM users WHERE telegram_id = ?').get(telegramId);
  return user ? user.role : ROLE_USER;
}

// Get ticket price for a group (falls back to default)
function getGroupConfig(chatId) {
  return db.prepare('SELECT * FROM group_configs WHERE chat_id = ? AND enabled = 1').get(chatId);
}

function getTicketPrice(chatId) {
  const config = getGroupConfig(chatId);
  return config ? config.ticket_price_sats : GROUP_JOIN_TICKET_SATS;
}

// LND REST API helper
const httpsAgent = new https.Agent({
  ca: LND_TLS_CERT,
  rejectUnauthorized: false  // Self-signed cert from LND
});

async function lndRequest(method, endpoint, data = null) {
  const url = `https://${LND_REST_HOST}${endpoint}`;
  const options = {
    method,
    headers: {
      'Grpc-Metadata-macaroon': LND_MACAROON
    },
    agent: httpsAgent
  };

  if (data && method !== 'GET') {
    options.headers['Content-Type'] = 'application/json';
    options.body = JSON.stringify(data);
  }

  try {
    const fetch = (await import('node-fetch')).default;
    const response = await fetch(url, options);
    const text = await response.text();
    
    if (!response.ok) {
      throw new Error(`LND Error: ${response.status} - ${text}`);
    }
    
    return text ? JSON.parse(text) : {};
  } catch (error) {
    console.error('LND Request failed:', error);
    throw error;
  }
}

// Database helpers
function getOrCreateUser(telegramId, username) {
  let user = db.prepare('SELECT * FROM users WHERE telegram_id = ?').get(telegramId);
  
  if (!user) {
    db.prepare('INSERT INTO users (telegram_id, username, balance_sats) VALUES (?, ?, 0)')
      .run(telegramId, username);
    user = db.prepare('SELECT * FROM users WHERE telegram_id = ?').get(telegramId);
  }
  
  return user;
}

// Atomic balance update - both operations in a single transaction
const updateBalanceAtomic = db.transaction((telegramId, amountSats, type, description, paymentHash, feeSats) => {
  db.prepare('UPDATE users SET balance_sats = balance_sats + ? WHERE telegram_id = ?')
    .run(amountSats, telegramId);
  
  db.prepare(`
    INSERT INTO transactions (telegram_id, type, amount_sats, fee_sats, description, payment_hash)
    VALUES (?, ?, ?, ?, ?, ?)
  `).run(telegramId, type, amountSats, feeSats, description, paymentHash);
});

function updateBalance(telegramId, amountSats, type, description, paymentHash = null, feeSats = 0) {
  updateBalanceAtomic(telegramId, amountSats, type, description, paymentHash, feeSats);
}

// Atomic tip transfer - debit sender + credit recipient in one transaction
const tipTransferAtomic = db.transaction((senderId, senderUsername, recipientId, recipientUsername, amount, fee) => {
  const total = amount + fee;
  
  // Verify sender has enough (prevent race condition)
  const sender = db.prepare('SELECT balance_sats FROM users WHERE telegram_id = ?').get(senderId);
  if (sender.balance_sats < total) {
    throw new Error('INSUFFICIENT_BALANCE');
  }
  
  // Deduct from sender
  db.prepare('UPDATE users SET balance_sats = balance_sats - ? WHERE telegram_id = ?').run(total, senderId);
  db.prepare(`INSERT INTO transactions (telegram_id, type, amount_sats, fee_sats, description) VALUES (?, 'tip_sent', ?, ?, ?)`)
    .run(senderId, -total, fee, `Propina a @${recipientUsername || recipientId}`);
  
  // Credit recipient
  db.prepare('UPDATE users SET balance_sats = balance_sats + ? WHERE telegram_id = ?').run(amount, recipientId);
  db.prepare(`INSERT INTO transactions (telegram_id, type, amount_sats, fee_sats, description) VALUES (?, 'tip_received', ?, 0, ?)`)
    .run(recipientId, amount, `Propina de @${senderUsername || senderId}`);
  
  return { senderNewBalance: sender.balance_sats - total, recipientNewBalance: amount };
});

// Command handlers

// Escape Markdown special chars in dynamic content
const escMd = (s) => String(s).replace(/([_*`\[\]])/g, '\\$1');

bot.onText(/\/start/, async (msg) => {
  const chatId = msg.chat.id;
  const user = getOrCreateUser(msg.from.id, msg.from.username);
  logActivity('START', msg.from.id, msg.from.username, { chat_id: chatId });
  
  const commands = [
    `/balance - Ver tu saldo`,
    `/receive <cantidad> - Crear invoice para recibir`,
    `/send <invoice> - Pagar un invoice`,
    `/pay <invoice> - Pagar con confirmaci√≥n`,
    `/tip <@usuario> <cantidad> - Enviar propina`,
    `  (Tambi√©n: responder a mensaje + /tip <cantidad>)`,
    `/giveaway <sats> - Giveaway r√°pido (grupos)`,
    `/giveflip <sats> [N] - Giveaway aleatorio (grupos)`,
    `/fundraise <X> <N> @user - Crowdfunding (grupos)`,
    `/history - Ver historial de transacciones`
  ];
  
  // Admin commands (only show to Daniel)
  if (isOwner(msg.from.id)) {
    commands.push(
      `\nüîß Admin:`, 
      `/admin - Panel de administraci√≥n completo`,
      `/stats - Estad√≠sticas detalladas`
    );
  }
  
  commands.push(
    `\nüé´ Grupos:`,
    `Precio por defecto: ${GROUP_JOIN_TICKET_SATS} sats (cada grupo fija su precio)`,
    `/mygroups - Ver tus grupos configurados`,
    `/setupgroup [precio] - Configurar grupo (enviar dentro del grupo)`
  );
  
  await bot.sendMessage(chatId, 
    `‚ö° Bienvenido a Lightning Easy Bot!\n\n` +
    `Tu wallet custodial est√° lista.\n\n` +
    `Comandos disponibles:\n` +
    commands.join('\n') +
    `\n\nTu ID: ${user.telegram_id}`
  );
});

bot.onText(/\/balance/, async (msg) => {
  const chatId = msg.chat.id;
  const user = getOrCreateUser(msg.from.id, msg.from.username);
  logActivity('BALANCE', msg.from.id, msg.from.username, { chat_id: chatId, balance: user.balance_sats });
  
  // ALWAYS respond via DM (never in groups for privacy)
  const responseChat = msg.from.id;
  
  if (chatId !== responseChat) {
    // Command was sent in a group - notify user to check DM
    await bot.sendMessage(chatId, 'üì® Te envi√© la informaci√≥n por mensaje privado.');
  }
  
  await bot.sendMessage(responseChat,
    `üí∞ Balance: ${user.balance_sats.toLocaleString()} sats\n\n` +
    `üí∏ Fees:\n` +
    `  ‚Ä¢ Dep√≥sitos: ${FEE_DEPOSIT/100}%\n` +
    `  ‚Ä¢ Retiros: ${FEE_WITHDRAWAL/100}%\n` +
    `  ‚Ä¢ Transferencias internas: ${FEE_INTERNAL_TRANSFER/100}%`
  );
});

bot.onText(/\/receive (.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  if (!checkRateLimit(msg.from.id)) {
    logActivity('RATE_LIMITED', msg.from.id, msg.from.username, { command: 'receive' });
    return bot.sendMessage(msg.from.id, '‚è≥ Demasiados comandos. Espera un momento.');
  }
  const user = getOrCreateUser(msg.from.id, msg.from.username);
  const amount = parseInt(match[1]);
  logActivity('RECEIVE', msg.from.id, msg.from.username, { chat_id: chatId, amount });
  
  // ALWAYS respond via DM (never in groups for privacy)
  const responseChat = msg.from.id;
  
  if (isNaN(amount) || amount <= 0) {
    return bot.sendMessage(responseChat, '‚ùå Cantidad inv√°lida. Usa: /receive 1000');
  }
  
  if (amount > 10_000_000) {
    return bot.sendMessage(responseChat, '‚ùå M√°ximo por invoice: 10,000,000 sats (0.1 BTC)');
  }
  
  if (chatId !== responseChat) {
    // Command was sent in a group - notify user to check DM
    await bot.sendMessage(chatId, 'üì® Te envi√© el invoice por mensaje privado.');
  }
  
  try {
    const invoice = await lndRequest('POST', '/v1/invoices', {
      value: amount.toString(),
      memo: `Deposit for @${user.username || user.telegram_id}`,
      expiry: '3600'
    });
    
    // Store pending invoice
    db.prepare('INSERT OR REPLACE INTO pending_invoices (payment_hash, telegram_id, amount_sats) VALUES (?, ?, ?)')
      .run(invoice.r_hash, user.telegram_id, amount);
    
    // Generate QR code
    const qrBuffer = await QRCode.toBuffer(invoice.payment_request.toUpperCase(), {
      width: 512,
      margin: 2,
      errorCorrectionLevel: 'M'
    });
    
    const caption = 
      `‚ö° Invoice creado\n\n` +
      `Cantidad: ${amount} sats\n` +
      `Expira en: 1 hora\n\n` +
      `\`${invoice.payment_request}\``;
    
    await bot.sendPhoto(responseChat, qrBuffer, {
      caption,
      parse_mode: 'Markdown'
    });
  } catch (error) {
    console.error('Invoice creation failed:', error);
    await bot.sendMessage(responseChat, '‚ùå Error creando invoice. Intenta de nuevo.');
  }
});

bot.onText(/\/send (.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  if (!checkRateLimit(msg.from.id, true)) {
    logActivity('RATE_LIMITED', msg.from.id, msg.from.username, { command: 'send' });
    return bot.sendMessage(msg.from.id, '‚è≥ Demasiados comandos. Espera un momento.');
  }
  const user = getOrCreateUser(msg.from.id, msg.from.username);
  const paymentRequest = match[1].trim();
  logActivity('SEND', msg.from.id, msg.from.username, { chat_id: chatId, invoice: paymentRequest.substring(0, 30) + '...' });
  
  // ALWAYS respond via DM (never in groups for privacy)
  const responseChat = msg.from.id;
  
  if (chatId !== responseChat) {
    // Command was sent in a group - notify user to check DM
    await bot.sendMessage(chatId, 'üì® Procesando pago - revisa tu mensaje privado.');
  }
  
  try {
    // Decode invoice to get amount
    const decoded = await lndRequest('GET', `/v1/payreq/${paymentRequest}`);
    const amount = parseInt(decoded.num_satoshis);
    const fee = Math.ceil(amount * FEE_WITHDRAWAL / 10000);
    const total = amount + fee;
    
    if (user.balance_sats < total) {
      logActivity('SEND_FAIL', msg.from.id, msg.from.username, { reason: 'insufficient_balance', needed: total, has: user.balance_sats });
      return bot.sendMessage(responseChat, 
        `‚ùå Balance insuficiente\n\n` +
        `Necesitas: ${total} sats (${amount} + ${fee} fee)\n` +
        `Tienes: ${user.balance_sats} sats`
      );
    }
    
    // Pay invoice
    const payment = await lndRequest('POST', '/v1/channels/transactions', {
      payment_request: paymentRequest,
      timeout_seconds: 60
    });
    
    if (payment.payment_error) {
      throw new Error(payment.payment_error);
    }
    
    // Update balance
    updateBalance(user.telegram_id, -total, 'withdrawal', 
      `Payment: ${decoded.description || 'No description'}`,
      payment.payment_hash, fee);
    
    logActivity('SEND_OK', msg.from.id, msg.from.username, { amount, fee, new_balance: user.balance_sats - total });
    
    await bot.sendMessage(responseChat,
      `‚úÖ Pago enviado\n\n` +
      `Cantidad: ${amount} sats\n` +
      `Fee: ${fee} sats\n` +
      `Balance: ${user.balance_sats - total} sats`
    );
  } catch (error) {
    logActivity('SEND_ERROR', msg.from.id, msg.from.username, { error: error.message });
    console.error('Payment failed:', error);
    await bot.sendMessage(responseChat, `‚ùå Error: ${error.message}`);
  }
});

bot.onText(/\/history/, async (msg) => {
  const chatId = msg.chat.id;
  const user = getOrCreateUser(msg.from.id, msg.from.username);
  logActivity('HISTORY', msg.from.id, msg.from.username, { chat_id: chatId });
  
  // ALWAYS respond via DM (financial data = private)
  const responseChat = msg.from.id;
  if (chatId !== responseChat) {
    await bot.sendMessage(chatId, 'üì® Te envi√© el historial por mensaje privado.');
  }
  
  const txs = db.prepare(`
    SELECT * FROM transactions 
    WHERE telegram_id = ? 
    ORDER BY created_at DESC 
    LIMIT 10
  `).all(user.telegram_id);
  
  if (txs.length === 0) {
    return bot.sendMessage(responseChat, 'üìú Sin transacciones todav√≠a');
  }
  
  let message = 'üìú √öltimas transacciones:\n\n';
  
  for (const tx of txs) {
    const date = new Date(tx.created_at * 1000).toLocaleString('es-ES');
    const sign = tx.amount_sats > 0 ? '+' : '';
    message += `${date}\n`;
    message += `${tx.type}: ${sign}${tx.amount_sats} sats`;
    if (tx.fee_sats > 0) message += ` (fee: ${tx.fee_sats})`;
    message += `\n${tx.description}\n\n`;
  }
  
  await bot.sendMessage(responseChat, message);
});

bot.onText(/\/stats/, async (msg) => {
  const chatId = msg.chat.id;
  logActivity('STATS', msg.from.id, msg.from.username, { chat_id: chatId });
  
  // Admin only command - always respond via DM
  if (!isOwner(msg.from.id)) {
    return bot.sendMessage(msg.from.id, '‚ùå Comando solo para administradores');
  }
  
  try {
    // Generate quick stats
    const totalUsers = db.prepare('SELECT COUNT(*) as count FROM users').get();
    const usersWithBalance = db.prepare('SELECT COUNT(*) as count FROM users WHERE balance_sats > 0').get();
    const totalBalance = db.prepare('SELECT SUM(balance_sats) as total FROM users').get();
    const totalRevenue = db.prepare('SELECT SUM(fee_sats) as total FROM transactions WHERE fee_sats > 0').get();
    const totalTxs = db.prepare('SELECT COUNT(*) as count FROM transactions').get();
    
    const txByType = db.prepare(`
      SELECT type, COUNT(*) as count 
      FROM transactions 
      GROUP BY type 
      ORDER BY count DESC
    `).all();
    
    const recentUsers = db.prepare(`
      SELECT COUNT(*) as count 
      FROM users 
      WHERE created_at >= strftime('%s', 'now', '-7 days')
    `).get();
    
    const recentRevenue = db.prepare(`
      SELECT SUM(fee_sats) as total 
      FROM transactions 
      WHERE fee_sats > 0 AND created_at >= strftime('%s', 'now', '-7 days')
    `).get();
    
    let statsMessage = 'üìä *Estad√≠sticas del Bot*\n\n';
    
    statsMessage += '*Usuarios*\n';
    statsMessage += `Total: ${totalUsers.count}\n`;
    statsMessage += `Con saldo: ${usersWithBalance.count}\n`;
    statsMessage += `Nuevos (7d): ${recentUsers.count}\n`;
    statsMessage += `Balance total: ${(totalBalance.total || 0).toLocaleString()} sats\n\n`;
    
    statsMessage += '*Transacciones*\n';
    statsMessage += `Total: ${totalTxs.count}\n`;
    if (txByType.length > 0) {
      txByType.forEach(row => {
        statsMessage += `  ${escMd(row.type)}: ${row.count}\n`;
      });
    }
    statsMessage += '\n';
    
    statsMessage += '*Revenue*\n';
    statsMessage += `Total fees: ${(totalRevenue.total || 0).toLocaleString()} sats\n`;
    statsMessage += `Last 7 days: ${(recentRevenue.total || 0).toLocaleString()} sats\n`;
    
    const revenuePerUser = totalUsers.count > 0 ? Math.round((totalRevenue.total || 0) / totalUsers.count) : 0;
    statsMessage += `Por usuario: ${revenuePerUser} sats\n\n`;
    
    // Group tickets stats
    const totalJoinRequests = db.prepare('SELECT COUNT(*) as count FROM group_join_requests').get();
    const approvedJoins = db.prepare("SELECT COUNT(*) as count FROM group_join_requests WHERE status = 'approved'").get();
    const expiredJoins = db.prepare("SELECT COUNT(*) as count FROM group_join_requests WHERE status = 'expired'").get();
    const pendingJoins = db.prepare("SELECT COUNT(*) as count FROM group_join_requests WHERE status = 'pending'").get();
    const ticketRevenue = db.prepare(`
      SELECT SUM(amount_sats) as total 
      FROM group_join_requests 
      WHERE status = 'approved'
    `).get();
    
    if (totalJoinRequests.count > 0) {
      statsMessage += '*Tickets de Grupo*\n';
      statsMessage += `Total solicitudes: ${totalJoinRequests.count}\n`;
      statsMessage += `  Aprobadas: ${approvedJoins.count}\n`;
      statsMessage += `  Expiradas: ${expiredJoins.count}\n`;
      statsMessage += `  Pendientes: ${pendingJoins.count}\n`;
      statsMessage += `Revenue tickets: ${(ticketRevenue.total || 0).toLocaleString()} sats\n`;
      const conversionRate = totalJoinRequests.count > 0 ? 
        Math.round((approvedJoins.count / totalJoinRequests.count) * 100) : 0;
      statsMessage += `Conversi√≥n: ${conversionRate}%\n\n`;
    }
    
    statsMessage += `_√öltima actualizaci√≥n: ${new Date().toLocaleString('es-ES')}_`;
    
    await bot.sendMessage(msg.from.id, statsMessage, { parse_mode: 'Markdown' });
  } catch (error) {
    console.error('Stats command error:', error);
    await bot.sendMessage(msg.from.id, '‚ùå Error generando estad√≠sticas');
  }
});

// /admin - Full admin panel with system health
bot.onText(/\/admin/, async (msg) => {
  if (!isOwner(msg.from.id)) {
    return bot.sendMessage(msg.chat.id, '‚ùå Comando solo para administradores');
  }
  logActivity('ADMIN', msg.from.id, msg.from.username, {});
  
  try {
    // DB stats
    const totalUsers = db.prepare('SELECT COUNT(*) as c FROM users').get().c;
    const totalBalance = db.prepare('SELECT COALESCE(SUM(balance_sats),0) as c FROM users').get().c;
    const totalTxs = db.prepare('SELECT COUNT(*) as c FROM transactions').get().c;
    const totalFees = db.prepare('SELECT COALESCE(SUM(fee_sats),0) as c FROM transactions WHERE fee_sats > 0').get().c;
    const pendingInvoices = db.prepare('SELECT COUNT(*) as c FROM pending_invoices').get().c;
    const pendingJoins = db.prepare("SELECT COUNT(*) as c FROM group_join_requests WHERE status='pending'").get().c;
    const approvedJoins = db.prepare("SELECT COUNT(*) as c FROM group_join_requests WHERE status='approved'").get().c;
    const configuredGroups = db.prepare('SELECT COUNT(*) as c FROM group_configs WHERE enabled=1').get().c;
    
    // LND status
    let lndStatus = '‚ùå No disponible';
    try {
      const info = await lndRequest('GET', '/v1/getinfo');
      const balance = await lndRequest('GET', '/v1/balance/blockchain');
      lndStatus = `‚úÖ Synced: ${info.synced_to_chain}\n` +
        `  Peers: ${info.num_peers} | Channels: ${info.num_active_channels}\n` +
        `  Balance: ${parseInt(balance.total_balance).toLocaleString()} sats\n` +
        `  Block: ${info.block_height}`;
    } catch (e) {
      lndStatus = `‚ùå ${escMd(e.message)}`;
    }
    
    // Activity log stats
    let activityStats = '';
    try {
      const logContent = fs.readFileSync(join(__dirname, 'activity.log'), 'utf-8');
      const lines = logContent.trim().split('\n').filter(Boolean);
      const events = {};
      const uniqueUsers = new Set();
      for (const line of lines) {
        try {
          const e = JSON.parse(line);
          events[e.event] = (events[e.event] || 0) + 1;
          if (e.user_id) uniqueUsers.add(e.user_id);
        } catch {}
      }
      activityStats = `\nüìã *Activity Log*\n` +
        `  Eventos totales: ${lines.length}\n` +
        `  Usuarios √∫nicos: ${uniqueUsers.size}\n` +
        `  Top eventos: ${escMd(Object.entries(events).sort((a,b) => b[1]-a[1]).slice(0,5).map(([k,v]) => `${k}(${v})`).join(', '))}`;
    } catch {
      activityStats = '\nüìã Activity log: sin datos a√∫n';
    }
    
    // Group configs
    let groupList = '';
    const groups = db.prepare('SELECT * FROM group_configs WHERE enabled=1').all();
    if (groups.length > 0) {
      groupList = '\n\nüé´ *Grupos Configurados*\n';
      for (const g of groups) {
        groupList += `  ${escMd(g.title)}: ${g.ticket_price_sats} sats (ID: ${g.chat_id})\n`;
      }
    }
    
    const panel = 
      `üîß *Admin Panel*\n\n` +
      `üë• *Usuarios*\n` +
      `  Total: ${totalUsers}\n` +
      `  Balance total: ${totalBalance.toLocaleString()} sats\n\n` +
      `üí∞ *Transacciones*\n` +
      `  Total: ${totalTxs}\n` +
      `  Fees recaudados: ${totalFees.toLocaleString()} sats\n` +
      `  Invoices pendientes: ${pendingInvoices}\n\n` +
      `üé´ *Tickets*\n` +
      `  Pendientes: ${pendingJoins}\n` +
      `  Aprobados: ${approvedJoins}\n` +
      `  Grupos configurados: ${configuredGroups}\n\n` +
      `‚ö° *LND*\n${lndStatus}` +
      activityStats +
      groupList +
      `\n\n_${new Date().toISOString()}_`;
    
    await bot.sendMessage(msg.from.id, panel, { parse_mode: 'Markdown' });
  } catch (error) {
    logActivity('ADMIN_ERROR', msg.from.id, msg.from.username, { error: error.message });
    await bot.sendMessage(msg.from.id, `‚ùå Error: ${error.message}`);
  }
});

// /setrole - Owner only: assign roles to users
bot.onText(/\/setrole\s+@?(\w+)\s+(owner|operator|admin|user)/, async (msg, match) => {
  if (!isOwner(msg.from.id)) {
    return bot.sendMessage(msg.from.id, '‚ùå Solo el propietario puede asignar roles.');
  }
  
  const targetIdentifier = match[1];
  const newRole = match[2];
  logActivity('SETROLE', msg.from.id, msg.from.username, { target: targetIdentifier, role: newRole });
  
  // Find user by username or ID
  let target;
  if (/^\d+$/.test(targetIdentifier)) {
    target = db.prepare('SELECT * FROM users WHERE telegram_id = ?').get(parseInt(targetIdentifier));
  } else {
    target = db.prepare('SELECT * FROM users WHERE username = ?').get(targetIdentifier);
  }
  
  if (!target) {
    return bot.sendMessage(msg.from.id, '‚ùå Usuario no encontrado. Debe haber usado /start primero.');
  }
  
  db.prepare('UPDATE users SET role = ? WHERE telegram_id = ?').run(newRole, target.telegram_id);
  logActivity('ROLE_CHANGED', target.telegram_id, target.username, { new_role: newRole, changed_by: msg.from.username });
  
  await bot.sendMessage(msg.from.id, 
    `‚úÖ Rol actualizado\n\n` +
    `Usuario: @${target.username || target.telegram_id}\n` +
    `Rol: ${newRole}\n\n` +
    `Roles disponibles:\n` +
    `‚Ä¢ owner ‚Äî acceso total\n` +
    `‚Ä¢ operator ‚Äî acceso operacional\n` +
    `‚Ä¢ admin ‚Äî gesti√≥n de grupos\n` +
    `‚Ä¢ user ‚Äî usuario normal`
  );
});

// /users - Owner only: list all users with roles and balances
bot.onText(/\/users/, async (msg) => {
  if (!isOwner(msg.from.id)) {
    return bot.sendMessage(msg.from.id, '‚ùå Solo el propietario puede ver la lista de usuarios.');
  }
  logActivity('USERS_LIST', msg.from.id, msg.from.username, {});
  
  const users = db.prepare('SELECT * FROM users ORDER BY balance_sats DESC').all();
  
  if (users.length === 0) {
    return bot.sendMessage(msg.from.id, 'üìã No hay usuarios registrados.');
  }
  
  let message = 'üë• *Usuarios Registrados*\n\n';
  for (const u of users) {
    const roleEmoji = { owner: 'üëë', operator: 'ü§ñ', admin: 'üõ°Ô∏è', user: 'üë§' }[u.role] || 'üë§';
    message += `${roleEmoji} @${u.username || u.telegram_id}`;
    message += ` | ${u.balance_sats.toLocaleString()} sats`;
    message += ` | ${u.role}\n`;
  }
  
  await bot.sendMessage(msg.from.id, message, { parse_mode: 'Markdown' });
});

bot.onText(/\/join(?:\s+(.+))?/, async (msg, match) => {
  const userId = msg.from.id;
  const username = msg.from.username;
  const chatIdArg = match[1]?.trim();
  logActivity('JOIN', userId, username, { target_chat: chatIdArg || 'none' });
  
  if (!chatIdArg) {
    return bot.sendMessage(userId, 
      '‚ùå Uso: /join <chat_id>\n\n' +
      'Necesitas el ID del grupo al que quieres unirte.\n' +
      'P√≠dele el ID al admin del grupo.'
    );
  }
  
  const targetChatId = parseInt(chatIdArg);
  
  if (isNaN(targetChatId)) {
    return bot.sendMessage(userId, '‚ùå ID de grupo inv√°lido');
  }
  
  try {
    // Ensure user exists
    getOrCreateUser(userId, username);
    
    // Check if bot is admin in target group
    let chatInfo;
    try {
      chatInfo = await bot.getChat(targetChatId);
      const botMember = await bot.getChatMember(targetChatId, bot.options.polling ? (await bot.getMe()).id : 0);
      
      if (botMember.status !== 'administrator' && botMember.status !== 'creator') {
        return bot.sendMessage(userId, 
          '‚ùå El bot no es administrador en ese grupo.\n' +
          'Contacta al admin del grupo para agregarlo.'
        );
      }
    } catch (error) {
      console.error('Error checking group:', error);
      return bot.sendMessage(userId, 
        '‚ùå No puedo acceder a ese grupo.\n' +
        'Verifica el ID o contacta al admin.'
      );
    }
    
    // Get ticket price for this group
    const ticketPrice = getTicketPrice(targetChatId);
    
    // Create invoice for ticket
    const invoice = await lndRequest('POST', '/v1/invoices', {
      value: ticketPrice.toString(),
      memo: `Ticket para ${chatInfo.title || `grupo ${targetChatId}`}`,
      expiry: GROUP_JOIN_TIMEOUT_SECONDS.toString()
    });
    
    // Store join request + invoice
    db.prepare(`
      INSERT INTO group_join_requests 
      (telegram_id, chat_id, payment_hash, amount_sats, status) 
      VALUES (?, ?, ?, ?, 'pending')
    `).run(userId, targetChatId, invoice.r_hash, ticketPrice);
    
    // Generate QR code
    const qrBuffer = await QRCode.toBuffer(invoice.payment_request.toUpperCase(), {
      width: 512,
      margin: 2,
      errorCorrectionLevel: 'M'
    });
    
    // Send invoice + QR to user
    const message = 
      `üé´ *Ticket de Entrada*\n\n` +
      `Grupo: ${chatInfo.title || 'Sin nombre'}\n` +
      `Precio: ${ticketPrice.toLocaleString()} sats\n` +
      `Expira en: ${Math.round(GROUP_JOIN_TIMEOUT_SECONDS / 60)} minutos\n\n` +
      `Escanea el QR o paga este invoice:\n\n` +
      `\`${invoice.payment_request}\`\n\n` +
      `_Una vez pagado, recibir√°s un enlace de invitaci√≥n de un solo uso._`;
    
    await bot.sendPhoto(userId, qrBuffer, { 
      caption: message, 
      parse_mode: 'Markdown' 
    });
    
  } catch (error) {
    console.error('Error in /join command:', error);
    await bot.sendMessage(userId, 
      '‚ùå Error procesando tu solicitud. Intenta de nuevo.'
    );
  }
});

// === GROUP MANAGEMENT COMMANDS ===

// /setupgroup - Register current group (must be sent FROM the group by an admin)
bot.onText(/\/setupgroup(?:\s+(\d+))?/, async (msg, match) => {
  const userId = msg.from.id;
  const chatId = msg.chat.id;
  const priceArg = match[1] ? parseInt(match[1]) : GROUP_JOIN_TICKET_SATS;
  logActivity('SETUPGROUP', userId, msg.from.username, { chat_id: chatId, price: priceArg });
  
  // Must be sent in a group
  if (chatId === userId) {
    return bot.sendMessage(chatId, 
      '‚ùå Env√≠a este comando *dentro del grupo* que quieres configurar.\n\n' +
      'Uso: `/setupgroup [precio_sats]`\n' +
      'Ejemplo: `/setupgroup 500`',
      { parse_mode: 'Markdown' }
    );
  }
  
  // Check if sender is admin of the group
  try {
    const member = await bot.getChatMember(chatId, userId);
    if (member.status !== 'administrator' && member.status !== 'creator') {
      return bot.sendMessage(chatId, '‚ùå Solo administradores del grupo pueden configurar tickets.');
    }
  } catch (error) {
    return bot.sendMessage(chatId, '‚ùå No pude verificar tu rol en el grupo.');
  }
  
  // Check bot is admin too
  try {
    const botInfo = await bot.getMe();
    const botMember = await bot.getChatMember(chatId, botInfo.id);
    if (botMember.status !== 'administrator') {
      return bot.sendMessage(chatId, '‚ùå El bot necesita ser administrador del grupo para gestionar tickets.');
    }
  } catch (error) {
    return bot.sendMessage(chatId, '‚ùå No pude verificar mis permisos en el grupo.');
  }
  
  if (isNaN(priceArg) || priceArg < 1) {
    return bot.sendMessage(chatId, '‚ùå Precio inv√°lido. M√≠nimo: 1 sat');
  }
  
  const chatInfo = await bot.getChat(chatId);
  const title = chatInfo.title || `Grupo ${chatId}`;
  
  // Upsert group config
  db.prepare(`
    INSERT INTO group_configs (chat_id, owner_telegram_id, title, ticket_price_sats, enabled, updated_at)
    VALUES (?, ?, ?, ?, 1, strftime('%s', 'now'))
    ON CONFLICT(chat_id) DO UPDATE SET
      owner_telegram_id = excluded.owner_telegram_id,
      title = excluded.title,
      ticket_price_sats = excluded.ticket_price_sats,
      enabled = 1,
      updated_at = strftime('%s', 'now')
  `).run(chatId, userId, title, priceArg);
  
  await bot.sendMessage(chatId,
    `‚úÖ *Grupo configurado*\n\n` +
    `Grupo: ${title}\n` +
    `Chat ID: \`${chatId}\`\n` +
    `Precio ticket: ${priceArg.toLocaleString()} sats\n` +
    `Admin: @${msg.from.username || userId}\n\n` +
    `Los usuarios pueden entrar con:\n` +
    `\`/join ${chatId}\`\n\n` +
    `_Cambiar precio: /setprice <sats>_`,
    { parse_mode: 'Markdown' }
  );
});

// /setprice - Change ticket price for current group
bot.onText(/\/setprice\s+(\d+)/, async (msg, match) => {
  const userId = msg.from.id;
  const chatId = msg.chat.id;
  const newPrice = parseInt(match[1]);
  logActivity('SETPRICE', userId, msg.from.username, { chat_id: chatId, new_price: newPrice });
  
  if (chatId === userId) {
    return bot.sendMessage(chatId, '‚ùå Env√≠a este comando dentro del grupo.');
  }
  
  if (isNaN(newPrice) || newPrice < 1) {
    return bot.sendMessage(chatId, '‚ùå Precio inv√°lido. M√≠nimo: 1 sat');
  }
  
  // Check if group is configured
  const config = getGroupConfig(chatId);
  if (!config) {
    return bot.sendMessage(chatId, '‚ùå Grupo no configurado. Usa /setupgroup primero.');
  }
  
  // Check if sender is the group owner or a group admin
  try {
    const member = await bot.getChatMember(chatId, userId);
    if (member.status !== 'administrator' && member.status !== 'creator') {
      return bot.sendMessage(chatId, '‚ùå Solo administradores pueden cambiar el precio.');
    }
  } catch (error) {
    return bot.sendMessage(chatId, '‚ùå No pude verificar tu rol.');
  }
  
  db.prepare(`
    UPDATE group_configs SET ticket_price_sats = ?, updated_at = strftime('%s', 'now') WHERE chat_id = ?
  `).run(newPrice, chatId);
  
  await bot.sendMessage(chatId,
    `‚úÖ Precio actualizado: *${newPrice.toLocaleString()} sats*`,
    { parse_mode: 'Markdown' }
  );
});

// /mygroups - List all groups owned/managed by this user
bot.onText(/\/mygroups/, async (msg) => {
  const userId = msg.from.id;
  logActivity('MYGROUPS', userId, msg.from.username, {});
  
  const groups = db.prepare(`
    SELECT gc.*, 
      (SELECT COUNT(*) FROM group_join_requests gjr WHERE gjr.chat_id = gc.chat_id AND gjr.status = 'approved') as total_tickets,
      (SELECT SUM(amount_sats) FROM group_join_requests gjr WHERE gjr.chat_id = gc.chat_id AND gjr.status = 'approved') as total_revenue
    FROM group_configs gc 
    WHERE gc.owner_telegram_id = ?
    ORDER BY gc.created_at DESC
  `).all(userId);
  
  if (groups.length === 0) {
    return bot.sendMessage(userId,
      'üìã No tienes grupos configurados.\n\n' +
      'Para configurar un grupo:\n' +
      '1. Agrega el bot al grupo como admin\n' +
      '2. Env√≠a `/setupgroup [precio]` dentro del grupo',
      { parse_mode: 'Markdown' }
    );
  }
  
  let message = 'üìã *Tus Grupos*\n\n';
  
  for (const g of groups) {
    const status = g.enabled ? 'üü¢' : 'üî¥';
    message += `${status} *${g.title}*\n`;
    message += `  ID: \`${g.chat_id}\`\n`;
    message += `  Precio: ${g.ticket_price_sats.toLocaleString()} sats\n`;
    message += `  Tickets vendidos: ${g.total_tickets || 0}\n`;
    message += `  Revenue: ${(g.total_revenue || 0).toLocaleString()} sats\n\n`;
  }
  
  message += '_Comandos: /setprice, /disablegroup, /enablegroup (dentro del grupo)_';
  
  await bot.sendMessage(userId, message, { parse_mode: 'Markdown' });
});

// /disablegroup - Disable tickets for current group
bot.onText(/\/disablegroup/, async (msg) => {
  const userId = msg.from.id;
  const chatId = msg.chat.id;
  logActivity('DISABLEGROUP', userId, msg.from.username, { chat_id: chatId });
  
  if (chatId === userId) {
    return bot.sendMessage(chatId, '‚ùå Env√≠a este comando dentro del grupo.');
  }
  
  const config = getGroupConfig(chatId);
  if (!config) {
    return bot.sendMessage(chatId, '‚ùå Grupo no configurado.');
  }
  
  try {
    const member = await bot.getChatMember(chatId, userId);
    if (member.status !== 'administrator' && member.status !== 'creator') {
      return bot.sendMessage(chatId, '‚ùå Solo administradores.');
    }
  } catch (error) {
    return bot.sendMessage(chatId, '‚ùå No pude verificar tu rol.');
  }
  
  db.prepare('UPDATE group_configs SET enabled = 0, updated_at = strftime(\'%s\', \'now\') WHERE chat_id = ?').run(chatId);
  await bot.sendMessage(chatId, 'üî¥ Tickets desactivados para este grupo. Usa /enablegroup para reactivar.');
});

// /enablegroup - Re-enable tickets for current group
bot.onText(/\/enablegroup/, async (msg) => {
  const userId = msg.from.id;
  const chatId = msg.chat.id;
  logActivity('ENABLEGROUP', userId, msg.from.username, { chat_id: chatId });
  
  if (chatId === userId) {
    return bot.sendMessage(chatId, '‚ùå Env√≠a este comando dentro del grupo.');
  }
  
  const existing = db.prepare('SELECT * FROM group_configs WHERE chat_id = ?').get(chatId);
  if (!existing) {
    return bot.sendMessage(chatId, '‚ùå Grupo no configurado. Usa /setupgroup primero.');
  }
  
  try {
    const member = await bot.getChatMember(chatId, userId);
    if (member.status !== 'administrator' && member.status !== 'creator') {
      return bot.sendMessage(chatId, '‚ùå Solo administradores.');
    }
  } catch (error) {
    return bot.sendMessage(chatId, '‚ùå No pude verificar tu rol.');
  }
  
  db.prepare('UPDATE group_configs SET enabled = 1, updated_at = strftime(\'%s\', \'now\') WHERE chat_id = ?').run(chatId);
  await bot.sendMessage(chatId, 'üü¢ Tickets reactivados para este grupo.');
});

// === FAUCET SYSTEM ===

// Create faucets table if not exists
db.exec(`
  CREATE TABLE IF NOT EXISTS faucets (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    creator_telegram_id INTEGER NOT NULL,
    chat_id INTEGER NOT NULL,
    total_sats INTEGER NOT NULL,
    per_claim_sats INTEGER NOT NULL,
    max_claims INTEGER NOT NULL,
    claims_made INTEGER DEFAULT 0,
    remaining_sats INTEGER NOT NULL,
    active INTEGER DEFAULT 1,
    created_at INTEGER DEFAULT (strftime('%s', 'now')),
    FOREIGN KEY (creator_telegram_id) REFERENCES users(telegram_id)
  );
  
  CREATE TABLE IF NOT EXISTS faucet_claims (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    faucet_id INTEGER NOT NULL,
    telegram_id INTEGER NOT NULL,
    amount_sats INTEGER NOT NULL,
    created_at INTEGER DEFAULT (strftime('%s', 'now')),
    FOREIGN KEY (faucet_id) REFERENCES faucets(id),
    FOREIGN KEY (telegram_id) REFERENCES users(telegram_id),
    UNIQUE(faucet_id, telegram_id)
  );
`);

// /faucet <total_sats> <max_claims> - Create a faucet in this chat
bot.onText(/\/faucet\s+(\d+)\s+(\d+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const totalSats = parseInt(match[1]);
  const maxClaims = parseInt(match[2]);
  
  logActivity('FAUCET_CREATE', userId, msg.from.username, { chat_id: chatId, total: totalSats, max_claims: maxClaims });
  
  if (totalSats < 1 || maxClaims < 1) {
    return bot.sendMessage(chatId, '‚ùå Uso: /faucet <sats_total> <num_personas>\nEjemplo: /faucet 1000 10');
  }
  
  if (totalSats > 1_000_000) {
    return bot.sendMessage(chatId, '‚ùå M√°ximo por faucet: 1,000,000 sats');
  }
  
  const perClaim = Math.floor(totalSats / maxClaims);
  if (perClaim < 1) {
    return bot.sendMessage(chatId, '‚ùå Cada persona recibir√≠a menos de 1 sat. Aumenta el total o reduce las personas.');
  }
  
  const user = getOrCreateUser(userId, msg.from.username);
  
  if (user.balance_sats < totalSats) {
    return bot.sendMessage(msg.from.id, 
      `‚ùå Balance insuficiente para crear faucet\n\n` +
      `Necesitas: ${totalSats.toLocaleString()} sats\n` +
      `Tienes: ${user.balance_sats.toLocaleString()} sats`
    );
  }
  
  // Deduct from creator
  updateBalance(userId, -totalSats, 'faucet_create', `Faucet: ${totalSats} sats / ${maxClaims} personas`, null, 0);
  
  // Create faucet
  const result = db.prepare(`
    INSERT INTO faucets (creator_telegram_id, chat_id, total_sats, per_claim_sats, max_claims, remaining_sats)
    VALUES (?, ?, ?, ?, ?, ?)
  `).run(userId, chatId, totalSats, perClaim, maxClaims, totalSats);
  
  logActivity('FAUCET_CREATED', userId, msg.from.username, { faucet_id: result.lastInsertRowid, total: totalSats, per_claim: perClaim, max_claims: maxClaims });
  
  await bot.sendMessage(chatId,
    `üö∞ *¬°Nuevo Faucet!*\n\n` +
    `@${msg.from.username || userId} ha creado un faucet\n\n` +
    `üí∞ Total: ${totalSats.toLocaleString()} sats\n` +
    `üë• Para: ${maxClaims} personas\n` +
    `üéÅ Cada uno recibe: ${perClaim.toLocaleString()} sats\n\n` +
    `Escribe /claim para reclamar tu parte!`,
    { parse_mode: 'Markdown' }
  );
});

// /claim - Claim from active faucet in this chat
bot.onText(/\/claim/, async (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  
  logActivity('FAUCET_CLAIM', userId, msg.from.username, { chat_id: chatId });
  
  // Find active faucet in this chat
  const faucet = db.prepare(`
    SELECT * FROM faucets 
    WHERE chat_id = ? AND active = 1 AND remaining_sats > 0 AND claims_made < max_claims
    ORDER BY created_at DESC LIMIT 1
  `).get(chatId);
  
  if (!faucet) {
    return bot.sendMessage(chatId, '‚ùå No hay faucet activo en este chat.');
  }
  
  // Check if already claimed
  const alreadyClaimed = db.prepare(
    'SELECT * FROM faucet_claims WHERE faucet_id = ? AND telegram_id = ?'
  ).get(faucet.id, userId);
  
  if (alreadyClaimed) {
    return bot.sendMessage(chatId, `‚ùå @${msg.from.username || userId} ya reclam√≥ de este faucet.`);
  }
  
  // Can't claim own faucet
  if (faucet.creator_telegram_id === userId) {
    return bot.sendMessage(chatId, '‚ùå No puedes reclamar de tu propio faucet.');
  }
  
  const claimAmount = faucet.per_claim_sats;
  
  // Ensure user exists
  getOrCreateUser(userId, msg.from.username);
  
  // Credit user and record claim (atomic)
  try {
    db.transaction(() => {
      // Credit claimer
      db.prepare('UPDATE users SET balance_sats = balance_sats + ? WHERE telegram_id = ?').run(claimAmount, userId);
      db.prepare(`INSERT INTO transactions (telegram_id, type, amount_sats, fee_sats, description) VALUES (?, 'faucet_claim', ?, 0, ?)`)
        .run(userId, claimAmount, `Faucet de @${db.prepare('SELECT username FROM users WHERE telegram_id = ?').get(faucet.creator_telegram_id)?.username || faucet.creator_telegram_id}`);
      
      // Update faucet
      db.prepare('UPDATE faucets SET claims_made = claims_made + 1, remaining_sats = remaining_sats - ? WHERE id = ?')
        .run(claimAmount, faucet.id);
      
      // Record claim
      db.prepare('INSERT INTO faucet_claims (faucet_id, telegram_id, amount_sats) VALUES (?, ?, ?)')
        .run(faucet.id, userId, claimAmount);
    })();
    
    const remaining = faucet.max_claims - faucet.claims_made - 1;
    
    logActivity('FAUCET_CLAIMED', userId, msg.from.username, { faucet_id: faucet.id, amount: claimAmount, remaining });
    
    let statusMsg = `üéÅ @${msg.from.username || userId} reclam√≥ ${claimAmount.toLocaleString()} sats!`;
    if (remaining > 0) {
      statusMsg += `\n\nüö∞ Quedan ${remaining} de ${faucet.max_claims} claims.`;
    } else {
      statusMsg += `\n\nüö∞ ¬°Faucet agotado!`;
      db.prepare('UPDATE faucets SET active = 0 WHERE id = ?').run(faucet.id);
    }
    
    await bot.sendMessage(chatId, statusMsg);
  } catch (error) {
    logActivity('FAUCET_CLAIM_ERROR', userId, msg.from.username, { error: error.message });
    await bot.sendMessage(chatId, '‚ùå Error procesando claim. Intenta de nuevo.');
  }
});

// === HELP COMMAND ===
bot.onText(/\/help(?:\s+(\w+))?/, async (msg, match) => {
  const chatId = msg.chat.id;
  const specificCmd = match[1]?.toLowerCase();
  logActivity('HELP', msg.from.id, msg.from.username, { chat_id: chatId, cmd: specificCmd || 'all' });
  
  const commands = {
    balance: { usage: '/balance', desc: 'Ver tu saldo actual y fees aplicables.' },
    receive: { usage: '/receive <sats>', desc: 'Crear un invoice Lightning para recibir sats. Genera QR + invoice copiable. M√°ximo: 10M sats.' },
    send: { usage: '/send <invoice>', desc: 'Pagar un invoice Lightning desde tu balance. Fee de retiro: 1%.' },
    pay: { usage: '/pay <invoice>', desc: 'Pagar un invoice Lightning externo (retiro con confirmaci√≥n). Fee: 1%. Muestra detalles antes de pagar.' },
    tip: { usage: '/tip @usuario <sats>\n/tip <sats> (respondiendo a mensaje)\n/tip --anon @usuario <sats>', desc: 'Enviar una propina a otro usuario. Fee: 0.5%. Usa --anon para enviar de forma an√≥nima.' },
    history: { usage: '/history', desc: 'Ver √∫ltimas 10 transacciones. Siempre se env√≠a por DM por privacidad.' },
    join: { usage: '/join <chat_id>', desc: 'Unirse a un grupo de pago. Te genera un invoice por el precio del ticket.' },
    faucet: { usage: '/faucet <sats_total> <personas>', desc: 'Crear un grifo de sats en el chat. Los usuarios reclaman con /claim.' },
    claim: { usage: '/claim', desc: 'Reclamar sats de un faucet activo en este chat.' },
    giveaway: { usage: '/giveaway <sats>', desc: 'Crear un giveaway en grupo. Primer usuario en reclamar se lleva los sats. Expira en 5 min.' },
    giveflip: { usage: '/giveflip <sats> [participantes]', desc: 'Giveaway aleatorio. Espera N participantes (default 2), ganador aleatorio. Expira en 10 min.' },
    fundraise: { usage: '/fundraise <sats_por_persona> <personas> @destinatario', desc: 'Crowdfunding. N personas aportan X sats cada una, todo va al destinatario. Expira en 30 min.' },
    coinflip: { usage: '/coinflip <sats> [participantes]', desc: 'Crear una loter√≠a. Cada participante paga la apuesta, un ganador se lleva todo. Default: 2 participantes.' },
    hide: { usage: '/hide <sats> <mensaje>', desc: 'Ocultar un mensaje detr√°s de un pago. Otros pagan para revelarlo.' },
    reveal: { usage: '/reveal <id>', desc: 'Pagar para revelar un mensaje oculto.' },
    calc: { usage: '/calc <sats>\n/calc $<usd>', desc: 'Convertir entre sats y USD al precio actual de BTC.' },
    setupgroup: { usage: '/setupgroup [precio]', desc: '(Admin) Configurar el grupo actual para tickets de entrada.' },
    setprice: { usage: '/setprice <sats>', desc: '(Admin) Cambiar precio del ticket de entrada del grupo.' },
    mygroups: { usage: '/mygroups', desc: 'Ver tus grupos configurados con stats.' },
  };
  
  if (specificCmd && commands[specificCmd]) {
    const cmd = commands[specificCmd];
    return bot.sendMessage(chatId,
      `üìñ */${specificCmd}*\n\n` +
      `Uso:\n\`${cmd.usage}\`\n\n` +
      `${cmd.desc}`,
      { parse_mode: 'Markdown' }
    );
  }
  
  if (specificCmd) {
    return bot.sendMessage(chatId, `‚ùå Comando desconocido: /${specificCmd}\n\nUsa /help para ver todos los comandos.`);
  }
  
  let message = '‚ö° *Lightning Easy Bot ‚Äî Comandos*\n\n';
  
  message += 'üí∞ *Wallet*\n';
  message += '/balance ‚Äî Ver saldo\n';
  message += '/receive <sats> ‚Äî Crear invoice\n';
  message += '/send <invoice> ‚Äî Pagar invoice\n';
  message += '/pay <invoice> ‚Äî Pagar con confirmaci√≥n\n';
  message += '/tip @user <sats> ‚Äî Propina\n';
  message += '/history ‚Äî Historial\n\n';
  
  message += 'üéÆ *Social*\n';
  message += '/faucet <sats> <personas> ‚Äî Grifo\n';
  message += '/claim ‚Äî Reclamar del grifo\n';
  message += '/giveaway <sats> ‚Äî Giveaway r√°pido\n';
  message += '/giveflip <sats> [N] ‚Äî Giveaway aleatorio\n';
  message += '/fundraise <X> <N> @user ‚Äî Crowdfunding\n';
  message += '/coinflip <sats> [N] ‚Äî Loter√≠a\n';
  message += '/hide <sats> <mensaje> ‚Äî Mensaje oculto\n';
  message += '/reveal <id> ‚Äî Revelar mensaje\n\n';
  
  message += 'üîß *Utilidades*\n';
  message += '/calc <sats|$usd> ‚Äî Convertir\n';
  message += '/join <chat\\_id> ‚Äî Unirse a grupo\n';

[Showing lines 1-1347 of 3171 (50.0KB limit). Use offset=1348 to continue.]

---

### ü§ñ **Claudio** [18:31:16]

message += '/help [comando] ‚Äî Ayuda detallada\n\n';
  
  if (isAdminOrAbove(msg.from.id)) {
    message += 'üõ°Ô∏è *Admin*\n';
    message += '/setupgroup ‚Äî Configurar grupo\n';
    message += '/setprice ‚Äî Cambiar precio\n';
    message += '/mygroups ‚Äî Mis grupos\n';
    if (isOwner(msg.from.id)) {
      message += '/admin ‚Äî Panel completo\n';
      message += '/stats ‚Äî Estad√≠sticas\n';
      message += '/users ‚Äî Lista usuarios\n';
      message += '/setrole ‚Äî Asignar roles\n';
    }
  }
  
  await bot.sendMessage(chatId, message, { parse_mode: 'Markdown' });
});

bot.onText(/\/tip(?:\s+(.+))?/, async (msg, match) => {
  const chatId = msg.chat.id;
  if (!checkRateLimit(msg.from.id, true)) {
    logActivity('RATE_LIMITED', msg.from.id, msg.from.username, { command: 'tip' });
    return bot.sendMessage(msg.from.id, '‚è≥ Demasiados comandos. Espera un momento.');
  }
  const sender = getOrCreateUser(msg.from.id, msg.from.username);
  
  // Parse arguments ‚Äî support: /tip @user amount, /tip --anon @user amount, /tip amount (reply)
  const rawArgs = (match[1] || '').trim();
  const isAnonymous = /--anon(ymous)?/i.test(rawArgs);
  const cleanArgs = rawArgs.replace(/--anon(ymous)?/gi, '').trim();
  
  logActivity('TIP', msg.from.id, msg.from.username, { chat_id: chatId, args: cleanArgs, anon: isAnonymous });
  
  let recipientIdentifier;
  let amount;
  
  // Check if replying to a message
  if (msg.reply_to_message) {
    // Replying: /tip <amount> or /tip --anon <amount>
    recipientIdentifier = msg.reply_to_message.from.id.toString();
    amount = parseInt(cleanArgs);
  } else {
    // Not replying: /tip @user <amount> or /tip <id> <amount>
    const parts = cleanArgs.split(/\s+/);
    if (parts.length < 2) {
      return bot.sendMessage(chatId, 
        '‚ùå Uso: /tip @usuario cantidad\n' +
        'O responde a un mensaje: /tip cantidad\n\n' +
        'Ejemplos:\n' +
        '/tip @DeltaGap 1000\n' +
        '/tip --anon @DeltaGap 1000\n' +
        '/tip 140223355 500\n' +
        '(Respondiendo) /tip 100'
      );
    }
    recipientIdentifier = parts[0].replace(/^@/, '');
    amount = parseInt(parts[1]);
  }
  
  if (isNaN(amount) || amount <= 0) {
    return bot.sendMessage(chatId, '‚ùå Cantidad inv√°lida');
  }
  
  // Find recipient by username or telegram_id
  let recipient;
  if (/^\d+$/.test(recipientIdentifier)) {
    // It's a telegram_id
    recipient = db.prepare('SELECT * FROM users WHERE telegram_id = ?').get(parseInt(recipientIdentifier));
  } else {
    // It's a username
    recipient = db.prepare('SELECT * FROM users WHERE username = ?').get(recipientIdentifier);
  }
  
  if (!recipient) {
    return bot.sendMessage(chatId, 
      '‚ùå Usuario no encontrado\n\n' +
      'El usuario debe haber usado el bot al menos una vez (/start)'
    );
  }
  
  if (recipient.telegram_id === sender.telegram_id) {
    return bot.sendMessage(chatId, '‚ùå No puedes enviarte propinas a ti mismo');
  }
  
  // Calculate fee (0.5% for internal transfers)
  const fee = Math.ceil(amount * FEE_INTERNAL_TRANSFER / 10000);
  const total = amount + fee;
  
  if (sender.balance_sats < total) {
    return bot.sendMessage(chatId, 
      `‚ùå Balance insuficiente\n\n` +
      `Necesitas: ${total} sats (${amount} + ${fee} fee)\n` +
      `Tienes: ${sender.balance_sats} sats`
    );
  }
  
  // Execute transfer (atomic - both operations in one transaction)
  try {
    const result = tipTransferAtomic(
      sender.telegram_id, sender.username,
      recipient.telegram_id, recipient.username,
      amount, fee
    );
    
    logActivity('TIP_OK', sender.telegram_id, sender.username, { 
      recipient_id: recipient.telegram_id, recipient_user: recipient.username,
      amount, fee, sender_new_balance: result.senderNewBalance, anonymous: isAnonymous
    });
    
    // ALWAYS respond via DM for privacy (no balance disclosure in groups)
    const responseChat = sender.telegram_id;
    
    if (chatId !== responseChat) {
      // Command was sent in a group - show public confirmation
      if (isAnonymous) {
        await bot.sendMessage(chatId,
          `‚úÖ Alguien envi√≥ ${amount} sats a @${recipient.username || 'usuario'} üï∂Ô∏è`
        );
      } else {
        await bot.sendMessage(chatId,
          `‚úÖ @${sender.username || 'Usuario'} envi√≥ ${amount} sats a @${recipient.username || 'usuario'}`
        );
      }
    }
    
    // Send detailed info to sender via DM
    await bot.sendMessage(responseChat,
      `‚úÖ Propina enviada${isAnonymous ? ' (an√≥nima)' : ''}\n\n` +
      `Destinatario: @${recipient.username || recipient.telegram_id}\n` +
      `Cantidad: ${amount} sats\n` +
      `Fee: ${fee} sats\n` +
      `Balance: ${result.senderNewBalance} sats`
    );
    
    // Notify recipient
    try {
      const fromText = isAnonymous ? 'Alguien an√≥nimo üï∂Ô∏è' : `@${sender.username || sender.telegram_id}`;
      await bot.sendMessage(recipient.telegram_id,
        `üéâ ¬°Recibiste una propina!\n\n` +
        `De: ${fromText}\n` +
        `Cantidad: ${amount} sats\n` +
        `Nuevo balance: ${(recipient.balance_sats + amount).toLocaleString()} sats`
      );
    } catch (error) {
      // Recipient might have blocked the bot
      console.log(`Could not notify recipient ${recipient.telegram_id}:`, error.message);
    }
  } catch (error) {
    console.error('Tip transfer failed:', error);
    const responseChat = sender.telegram_id;
    await bot.sendMessage(responseChat, '‚ùå Error procesando la propina. Intenta de nuevo.');
  }
});

// New member handler - verify they paid before allowing entry
bot.on('new_chat_members', async (msg) => {
  logActivity('NEW_CHAT_MEMBERS', null, null, { chat_id: msg.chat.id, count: msg.new_chat_members?.length });
  
  const chatId = msg.chat.id;
  const newMembers = msg.new_chat_members;
  
  if (!newMembers || newMembers.length === 0) {
    logActivity('NEW_CHAT_MEMBERS_EMPTY', null, null, { chat_id: chatId });
    return;
  }
  
  for (const member of newMembers) {
    logActivity('MEMBER_PROCESS', member.id, member.username, { chat_id: chatId, is_bot: member.is_bot });
    
    // Skip if it's the bot itself
    if (member.is_bot) {
      continue;
    }
    
    const userId = member.id;
    const username = member.username;
    const displayName = member.first_name || username || userId;
    
    logActivity('MEMBER_JOIN', userId, username, { chat_id: chatId });
    
    // Check if user has paid ticket for this group
    const paidTicket = db.prepare(`
      SELECT * FROM group_join_requests 
      WHERE telegram_id = ? AND chat_id = ? AND status = 'approved'
      ORDER BY created_at DESC LIMIT 1
    `).get(userId, chatId);
    
    if (!paidTicket) {
      // No paid ticket - kick and send invoice
      try {
        await bot.banChatMember(chatId, userId);
        await bot.unbanChatMember(chatId, userId);  // Unban so they can try again
        
        logActivity('MEMBER_KICKED_UNPAID', userId, username, { chat_id: chatId });
        
        // Send invoice via DM
        try {
          const chatInfo = await bot.getChat(chatId);
          const ticketPrice = getTicketPrice(chatId);
          
          // Create invoice
          const invoice = await lndRequest('POST', '/v1/invoices', {
            value: ticketPrice.toString(),
            memo: `Ticket para ${chatInfo.title || `grupo ${chatId}`}`,
            expiry: GROUP_JOIN_TIMEOUT_SECONDS.toString()
          });
          
          // Ensure user exists
          getOrCreateUser(userId, username);
          
          // Store join request
          db.prepare(`
            INSERT INTO group_join_requests 
            (telegram_id, chat_id, payment_hash, amount_sats, status) 
            VALUES (?, ?, ?, ?, 'pending')
          `).run(userId, chatId, invoice.r_hash, ticketPrice);
          
          // Generate QR
          const qrBuffer = await QRCode.toBuffer(invoice.payment_request.toUpperCase(), {
            width: 512,
            margin: 2,
            errorCorrectionLevel: 'M'
          });
          
          const message = 
            `‚õî *Entrada Requiere Pago*\n\n` +
            `Grupo: ${chatInfo.title || 'Sin nombre'}\n` +
            `Precio: ${ticketPrice.toLocaleString()} sats\n\n` +
            `Para entrar al grupo, paga este ticket:\n\n` +
            `Escanea el QR o paga el invoice:\n` +
            `\`${invoice.payment_request}\`\n\n` +
            `Despu√©s usa: /join ${chatId}\n\n` +
            `_Expira en ${Math.round(GROUP_JOIN_TIMEOUT_SECONDS / 60)} minutos_`;
          
          await bot.sendPhoto(userId, qrBuffer, {
            caption: message,
            parse_mode: 'Markdown'
          });
          
        } catch (dmError) {
          console.error('Could not send invoice DM:', dmError.message);
        }
        
      } catch (kickError) {
        console.error('Error kicking unpaid member:', kickError);
      }
    } else {
      // Paid ticket exists - welcome them
      try {
        await bot.sendMessage(chatId,
          `üëã Bienvenido ${displayName}!\n\n` +
          `Gracias por pagar tu ticket de entrada.`
        );
      } catch (welcomeError) {
        console.error('Could not send welcome message:', welcomeError);
      }
    }
  }
});

// Group join request handler
bot.on('chat_join_request', async (joinRequest) => {
  const userId = joinRequest.from.id;
  const chatId = joinRequest.chat.id;
  const username = joinRequest.from.username;
  const displayName = joinRequest.from.first_name || username || userId;
  
  logActivity('JOIN_REQUEST', userId, username, { chat_id: chatId });
  
  try {
    // Ensure user exists
    getOrCreateUser(userId, username);
    
    // Get ticket price for this group
    const ticketPrice = getTicketPrice(chatId);
    
    // Create invoice for ticket
    const invoice = await lndRequest('POST', '/v1/invoices', {
      value: ticketPrice.toString(),
      memo: `Ticket para grupo ${joinRequest.chat.title || chatId}`,
      expiry: GROUP_JOIN_TIMEOUT_SECONDS.toString()
    });
    
    // Store join request + invoice
    db.prepare(`
      INSERT INTO group_join_requests 
      (telegram_id, chat_id, payment_hash, amount_sats, status) 
      VALUES (?, ?, ?, ?, 'pending')
    `).run(userId, chatId, invoice.r_hash, ticketPrice);
    
    // Generate QR code
    const qrBuffer = await QRCode.toBuffer(invoice.payment_request.toUpperCase(), {
      width: 512,
      margin: 2,
      errorCorrectionLevel: 'M'
    });
    
    // Send invoice + QR to user via DM
    const userMessage = 
      `üé´ *Ticket de Entrada*\n\n` +
      `Grupo: ${joinRequest.chat.title || 'Sin nombre'}\n` +
      `Precio: ${ticketPrice.toLocaleString()} sats\n` +
      `Expira en: ${Math.round(GROUP_JOIN_TIMEOUT_SECONDS / 60)} minutos\n\n` +
      `Escanea el QR o paga este invoice:\n\n` +
      `\`${invoice.payment_request}\`\n\n` +
      `_Una vez pagado, ser√°s admitido autom√°ticamente._`;
    
    try {
      await bot.sendPhoto(userId, qrBuffer, { 
        caption: userMessage, 
        parse_mode: 'Markdown' 
      });
    } catch (dmError) {
      console.error('Could not send DM to user:', dmError.message);
      // Try text-only fallback
      await bot.sendMessage(userId, userMessage, { parse_mode: 'Markdown' });
    }
    
    // PRIVACY: Only notify group with minimal info (no QR/invoice leak)
    const groupMessage = 
      `üîî *Nueva Solicitud de Entrada*\n\n` +
      `Un usuario ha solicitado unirse.\n` +
      `Precio: ${ticketPrice.toLocaleString()} sats\n\n` +
      `_El usuario recibir√° acceso autom√°tico al pagar._`;
    
    try {
      await bot.sendMessage(chatId, groupMessage, { parse_mode: 'Markdown' });
    } catch (groupError) {
      console.error('Could not post to group:', groupError.message);
    }
    
  } catch (error) {
    console.error('Error handling join request:', error);
    
    // Try to notify user about error
    try {
      await bot.sendMessage(userId, 
        '‚ùå Error procesando tu solicitud de uni√≥n al grupo. Intenta de nuevo o contacta al admin.'
      );
    } catch (dmError) {
      console.error('Could not send DM to user:', dmError.message);
    }
    
    // Decline the request
    try {
      await bot.declineChatJoinRequest(chatId, userId);
    } catch (declineError) {
      console.error('Error declining join request:', declineError);
    }
  }
});

// === PAY COMMAND - Pay external Lightning invoice ===
bot.onText(/\/pay(?:\s+(.+))?/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  
  if (!checkRateLimit(userId, true)) {
    logActivity('RATE_LIMITED', userId, msg.from.username, { command: 'pay' });
    return bot.sendMessage(userId, '‚è≥ Demasiados comandos. Espera un momento.');
  }
  
  const invoiceArg = match[1]?.trim();
  
  if (!invoiceArg) {
    return bot.sendMessage(userId,
      '‚ùå Uso: /pay <invoice>\n\n' +
      'Ejemplo:\n' +
      '/pay lnbc100n1...\n\n' +
      'Paga un invoice Lightning externo (retiro).\n' +
      'Fee de retiro: 1%'
    );
  }
  
  const user = getOrCreateUser(userId, msg.from.username);
  const responseChat = userId; // Always DM for financial operations
  
  if (chatId !== responseChat) {
    await bot.sendMessage(chatId, 'üì® Procesando pago - revisa tu mensaje privado.');
  }
  
  logActivity('PAY', userId, msg.from.username, { invoice: invoiceArg.substring(0, 30) + '...' });
  
  try {
    // Decode invoice to get amount and details
    const decoded = await lndRequest('GET', `/v1/payreq/${invoiceArg}`);
    const amount = parseInt(decoded.num_satoshis || '0');
    
    if (amount === 0) {
      return bot.sendMessage(responseChat, '‚ùå El invoice no especifica una cantidad.');
    }
    
    const fee = Math.ceil(amount * FEE_WITHDRAWAL / 10000);
    const total = amount + fee;
    
    if (user.balance_sats < total) {
      logActivity('PAY_INSUFFICIENT', userId, msg.from.username, { needed: total, has: user.balance_sats });
      return bot.sendMessage(responseChat,
        `‚ùå Balance insuficiente\n\n` +
        `Necesitas: ${total.toLocaleString()} sats\n` +
        `  ‚Ä¢ Monto: ${amount.toLocaleString()} sats\n` +
        `  ‚Ä¢ Fee (1%): ${fee.toLocaleString()} sats\n\n` +
        `Tienes: ${user.balance_sats.toLocaleString()} sats`
      );
    }
    
    const description = decoded.description || 'Sin descripci√≥n';
    const destination = decoded.destination;
    
    // Ask for confirmation with inline button
    const confirmMsg = await bot.sendMessage(responseChat,
      `‚ö° *Confirmar Pago*\n\n` +
      `Monto: ${amount.toLocaleString()} sats\n` +
      `Fee (1%): ${fee.toLocaleString()} sats\n` +
      `*Total: ${total.toLocaleString()} sats*\n\n` +
      `Descripci√≥n: ${escMd(description.substring(0, 100))}\n` +
      `Destino: \`${destination}\`\n\n` +
      `_Balance despu√©s: ${(user.balance_sats - total).toLocaleString()} sats_`,
      {
        parse_mode: 'Markdown',
        reply_markup: {
          inline_keyboard: [[
            { text: '‚úÖ Confirmar Pago', callback_data: `pay_confirm:${userId}:${amount}:${fee}` }
          ]]
        }
      }
    );
    
    // Store invoice temporarily (we'll use a simple in-memory map for pending payments)
    if (!global.pendingPayments) global.pendingPayments = new Map();
    global.pendingPayments.set(`${userId}:${amount}:${fee}`, {
      invoice: invoiceArg,
      description,
      messageId: confirmMsg.message_id
    });
    
    // Auto-expire after 5 minutes
    setTimeout(() => {
      global.pendingPayments.delete(`${userId}:${amount}:${fee}`);
    }, 300000);
    
  } catch (error) {
    logActivity('PAY_DECODE_ERROR', userId, msg.from.username, { error: error.message });
    console.error('Pay decode error:', error);
    await bot.sendMessage(responseChat, `‚ùå Error decodificando invoice:\n${error.message}`);
  }
});

// === GIVEAWAY COMMAND - Quick giveaway in groups ===
bot.onText(/\/giveaway\s+(\d+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const amount = parseInt(match[1]);
  
  logActivity('GIVEAWAY_CREATE', userId, msg.from.username, { chat_id: chatId, amount });
  
  // Only works in groups
  if (chatId === userId) {
    return bot.sendMessage(chatId, '‚ùå Los giveaways solo funcionan en grupos.');
  }
  
  if (amount < 10) return bot.sendMessage(chatId, '‚ùå M√≠nimo: 10 sats');
  if (amount > 100_000) return bot.sendMessage(chatId, '‚ùå M√°ximo: 100,000 sats');
  
  const user = getOrCreateUser(userId, msg.from.username);
  
  if (user.balance_sats < amount) {
    return bot.sendMessage(userId,
      `‚ùå Balance insuficiente\n\n` +
      `Necesitas: ${amount.toLocaleString()} sats\n` +
      `Tienes: ${user.balance_sats.toLocaleString()} sats`
    );
  }
  
  // Deduct from giver
  updateBalance(userId, -amount, 'giveaway_create', `Giveaway: ${amount} sats`);
  
  // Create giveaway
  const now = Math.floor(Date.now() / 1000);
  const expiresAt = now + 300; // 5 minutes
  
  const result = db.prepare(`
    INSERT INTO giveaways (chat_id, giver_telegram_id, amount_sats, status, expires_at)
    VALUES (?, ?, ?, 'active', ?)
  `).run(chatId, userId, amount, expiresAt);
  const giveawayId = result.lastInsertRowid;
  
  const sentMsg = await bot.sendMessage(chatId,
    `üéÅ *¬°Giveaway!*\n\n` +
    `@${msg.from.username || userId} est√° regalando *${amount.toLocaleString()} sats*\n\n` +
    `¬°Primer usuario en reclamar se lo lleva todo!\n\n` +
    `_Expira en 5 minutos_`,
    {
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: [[
          { text: 'üéÅ Reclamar', callback_data: `giveaway_claim:${giveawayId}` }
        ]]
      }
    }
  );
  
  // Store message ID
  db.prepare('UPDATE giveaways SET message_id = ? WHERE id = ?').run(sentMsg.message_id, giveawayId);
  
  logActivity('GIVEAWAY_CREATED', userId, msg.from.username, { giveaway_id: giveawayId, amount });
});

// === GIVEFLIP COMMAND - Random giveaway ===
bot.onText(/\/giveflip\s+(\d+)(?:\s+(\d+))?/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const amount = parseInt(match[1]);
  const maxParticipants = parseInt(match[2] || '2');
  
  logActivity('GIVEFLIP_CREATE', userId, msg.from.username, { chat_id: chatId, amount, max: maxParticipants });
  
  // Only works in groups
  if (chatId === userId) {
    return bot.sendMessage(chatId, '‚ùå Los giveflips solo funcionan en grupos.');
  }
  
  if (amount < 10) return bot.sendMessage(chatId, '‚ùå M√≠nimo: 10 sats');
  if (amount > 500_000) return bot.sendMessage(chatId, '‚ùå M√°ximo: 500,000 sats');
  if (maxParticipants < 2 || maxParticipants > 20) return bot.sendMessage(chatId, '‚ùå Participantes: 2-20');
  
  const user = getOrCreateUser(userId, msg.from.username);
  
  if (user.balance_sats < amount) {
    return bot.sendMessage(userId,
      `‚ùå Balance insuficiente\n\n` +
      `Necesitas: ${amount.toLocaleString()} sats\n` +
      `Tienes: ${user.balance_sats.toLocaleString()} sats`
    );
  }
  
  // Deduct from giver
  updateBalance(userId, -amount, 'giveflip_create', `Giveflip: ${amount} sats x ${maxParticipants} participantes`);
  
  // Create giveflip
  const now = Math.floor(Date.now() / 1000);
  const expiresAt = now + 600; // 10 minutes
  
  const result = db.prepare(`
    INSERT INTO giveflips (chat_id, giver_telegram_id, amount_sats, max_participants, status, expires_at)
    VALUES (?, ?, ?, ?, 'active', ?)
  `).run(chatId, userId, amount, maxParticipants, expiresAt);
  const giveflipId = result.lastInsertRowid;
  
  const sentMsg = await bot.sendMessage(chatId,
    `üé≤ *¬°Giveflip!*\n\n` +
    `@${msg.from.username || userId} regala *${amount.toLocaleString()} sats*\n\n` +
    `Participantes: 0/${maxParticipants}\n` +
    `Un ganador aleatorio se lleva todo\n\n` +
    `_Expira en 10 minutos_`,
    {
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: [[
          { text: 'üé≤ Participar', callback_data: `giveflip_join:${giveflipId}` }
        ]]
      }
    }
  );
  
  // Store message ID
  db.prepare('UPDATE giveflips SET message_id = ? WHERE id = ?').run(sentMsg.message_id, giveflipId);
  
  logActivity('GIVEFLIP_CREATED', userId, msg.from.username, { giveflip_id: giveflipId, amount, max: maxParticipants });
});

// === FUNDRAISE COMMAND - Crowdfunding ===
bot.onText(/\/fundraise\s+(\d+)\s+(\d+)\s+@?(\w+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const amountPerPerson = parseInt(match[1]);
  const maxParticipants = parseInt(match[2]);
  const recipientIdentifier = match[3];
  
  logActivity('FUNDRAISE_CREATE', userId, msg.from.username, { 
    chat_id: chatId, 
    amount_per: amountPerPerson, 
    max: maxParticipants,
    recipient: recipientIdentifier
  });
  
  // Only works in groups
  if (chatId === userId) {
    return bot.sendMessage(chatId, '‚ùå Las fundraises solo funcionan en grupos.');
  }
  
  if (amountPerPerson < 10) return bot.sendMessage(chatId, '‚ùå M√≠nimo por persona: 10 sats');
  if (amountPerPerson > 100_000) return bot.sendMessage(chatId, '‚ùå M√°ximo por persona: 100,000 sats');
  if (maxParticipants < 2 || maxParticipants > 50) return bot.sendMessage(chatId, '‚ùå Participantes: 2-50');
  
  // Find recipient
  let recipient;
  if (/^\d+$/.test(recipientIdentifier)) {
    recipient = db.prepare('SELECT * FROM users WHERE telegram_id = ?').get(parseInt(recipientIdentifier));
  } else {
    recipient = db.prepare('SELECT * FROM users WHERE username = ?').get(recipientIdentifier);
  }
  
  if (!recipient) {
    return bot.sendMessage(chatId,
      `‚ùå Usuario @${recipientIdentifier} no encontrado.\n\n` +
      `El destinatario debe haber usado /start primero.`
    );
  }
  
  if (recipient.telegram_id === userId) {
    return bot.sendMessage(chatId, '‚ùå No puedes crear una fundraise para ti mismo.');
  }
  
  const user = getOrCreateUser(userId, msg.from.username);
  
  if (user.balance_sats < amountPerPerson) {
    return bot.sendMessage(userId,
      `‚ùå Balance insuficiente para auto-contribuir\n\n` +
      `Necesitas: ${amountPerPerson.toLocaleString()} sats\n` +
      `Tienes: ${user.balance_sats.toLocaleString()} sats`
    );
  }
  
  // Creator auto-contributes
  updateBalance(userId, -amountPerPerson, 'fundraise_contribute', 
    `Fundraise para @${recipient.username || recipient.telegram_id}: ${amountPerPerson} sats`);
  
  // Create fundraise
  const now = Math.floor(Date.now() / 1000);
  const expiresAt = now + 1800; // 30 minutes
  const totalGoal = amountPerPerson * maxParticipants;
  
  const result = db.prepare(`
    INSERT INTO fundraises (chat_id, creator_telegram_id, recipient_telegram_id, recipient_username,
                            amount_per_person, max_participants, status, expires_at)
    VALUES (?, ?, ?, ?, ?, ?, 'active', ?)
  `).run(chatId, userId, recipient.telegram_id, recipient.username, amountPerPerson, maxParticipants, expiresAt);
  const fundraiseId = result.lastInsertRowid;
  
  // Add creator as first contributor
  db.prepare('INSERT INTO fundraise_contributors (fundraise_id, telegram_id) VALUES (?, ?)').run(fundraiseId, userId);
  
  const sentMsg = await bot.sendMessage(chatId,
    `üí∞ *¬°Fundraise!*\n\n` +
    `Para: @${recipient.username || recipient.telegram_id}\n` +
    `Meta total: ${totalGoal.toLocaleString()} sats\n` +
    `Aporte por persona: ${amountPerPerson.toLocaleString()} sats\n\n` +
    `Contribuyentes: 1/${maxParticipants}\n` +
    `  ‚Ä¢ @${msg.from.username || userId} ‚úÖ\n\n` +
    `_Expira en 30 minutos_`,
    {
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: [[
          { text: `üí∞ Contribuir ${amountPerPerson.toLocaleString()} sats`, callback_data: `fundraise_contribute:${fundraiseId}` }
        ]]
      }
    }
  );
  
  // Store message ID
  db.prepare('UPDATE fundraises SET message_id = ? WHERE id = ?').run(sentMsg.message_id, fundraiseId);
  
  logActivity('FUNDRAISE_CREATED', userId, msg.from.username, { 
    fundraise_id: fundraiseId, 
    amount_per: amountPerPerson, 
    max: maxParticipants,
    recipient_id: recipient.telegram_id
  });
});

// === COINFLIP / LOTTERY SYSTEM ===

db.exec(`
  CREATE TABLE IF NOT EXISTS coinflips (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    creator_telegram_id INTEGER NOT NULL,
    chat_id INTEGER NOT NULL,
    bet_sats INTEGER NOT NULL,
    max_participants INTEGER NOT NULL,
    message_id INTEGER,
    active INTEGER DEFAULT 1,
    winner_telegram_id INTEGER,
    created_at INTEGER DEFAULT (strftime('%s', 'now')),
    FOREIGN KEY (creator_telegram_id) REFERENCES users(telegram_id)
  );
  
  CREATE TABLE IF NOT EXISTS coinflip_participants (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    coinflip_id INTEGER NOT NULL,
    telegram_id INTEGER NOT NULL,
    created_at INTEGER DEFAULT (strftime('%s', 'now')),
    FOREIGN KEY (coinflip_id) REFERENCES coinflips(id),
    FOREIGN KEY (telegram_id) REFERENCES users(telegram_id),
    UNIQUE(coinflip_id, telegram_id)
  );
`);

bot.onText(/\/coinflip\s+(\d+)(?:\s+(\d+))?/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const betSats = parseInt(match[1]);
  const maxParticipants = parseInt(match[2] || '2');
  
  logActivity('COINFLIP_CREATE', userId, msg.from.username, { chat_id: chatId, bet: betSats, max: maxParticipants });
  
  if (betSats < 10) return bot.sendMessage(chatId, '‚ùå Apuesta m√≠nima: 10 sats');
  if (betSats > 100_000) return bot.sendMessage(chatId, '‚ùå Apuesta m√°xima: 100,000 sats');
  if (maxParticipants < 2 || maxParticipants > 20) return bot.sendMessage(chatId, '‚ùå Participantes: 2-20');
  
  const user = getOrCreateUser(userId, msg.from.username);
  if (user.balance_sats < betSats) {
    return bot.sendMessage(msg.from.id, `‚ùå Balance insuficiente. Necesitas ${betSats} sats, tienes ${user.balance_sats} sats.`);
  }
  
  // Deduct bet from creator
  updateBalance(userId, -betSats, 'coinflip_bet', `Coinflip: ${betSats} sats x ${maxParticipants} personas`);
  
  // Create coinflip
  const result = db.prepare(`
    INSERT INTO coinflips (creator_telegram_id, chat_id, bet_sats, max_participants) VALUES (?, ?, ?, ?)
  `).run(userId, chatId, betSats, maxParticipants);
  const coinflipId = result.lastInsertRowid;
  
  // Add creator as first participant
  db.prepare('INSERT INTO coinflip_participants (coinflip_id, telegram_id) VALUES (?, ?)').run(coinflipId, userId);
  
  const pot = betSats * maxParticipants;
  
  const sentMsg = await bot.sendMessage(chatId,
    `üé∞ *¬°Coinflip #${coinflipId}!*\n\n` +
    `Apuesta: ${betSats.toLocaleString()} sats\n` +
    `Bote: ${pot.toLocaleString()} sats\n` +
    `Participantes: 1/${maxParticipants}\n\n` +
    `@${msg.from.username || userId} se ha unido ‚úÖ\n\n` +
    `_Usa el bot√≥n para unirte!_`,
    { 
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: [[
          { text: `üé∞ Unirse (${betSats} sats)`, callback_data: `coinflip_join:${coinflipId}` }
        ]]
      }
    }
  );
  
  // Store message ID for updates
  db.prepare('UPDATE coinflips SET message_id = ? WHERE id = ?').run(sentMsg.message_id, coinflipId);
  
  logActivity('COINFLIP_CREATED', userId, msg.from.username, { coinflip_id: coinflipId, bet: betSats, max: maxParticipants });
});

// Callback query handler - handles all inline button clicks
bot.on('callback_query', async (query) => {
  const data = query.data;
  if (!data) return;
  
  // Handle pay confirmation
  if (data.startsWith('pay_confirm:')) {
    const [_, userIdStr, amountStr, feeStr] = data.split(':');
    const userId = parseInt(userIdStr);
    const amount = parseInt(amountStr);
    const fee = parseInt(feeStr);
    const total = amount + fee;
    
    // Only the person who initiated can confirm
    if (query.from.id !== userId) {
      return bot.answerCallbackQuery(query.id, { text: '‚ùå Este pago no es tuyo', show_alert: true });
    }
    
    const key = `${userId}:${amount}:${fee}`;
    const pending = global.pendingPayments?.get(key);
    
    if (!pending) {
      return bot.answerCallbackQuery(query.id, { text: '‚ùå Pago expirado. Usa /pay de nuevo.', show_alert: true });
    }
    
    const user = getOrCreateUser(userId, query.from.username);
    
    // Double-check balance
    if (user.balance_sats < total) {
      global.pendingPayments.delete(key);
      return bot.answerCallbackQuery(query.id, { 
        text: `‚ùå Balance insuficiente. Necesitas ${total} sats.`, 
        show_alert: true 
      });
    }
    
    await bot.answerCallbackQuery(query.id, { text: '‚è≥ Procesando pago...' });
    
    try {
      // Pay invoice via LND
      const payment = await lndRequest('POST', '/v1/channels/transactions', {
        payment_request: pending.invoice,
        timeout_seconds: 60
      });
      
      if (payment.payment_error) {
        throw new Error(payment.payment_error);
      }
      
      // Update balance
      updateBalance(userId, -total, 'withdrawal', 
        `Pago: ${pending.description}`,
        payment.payment_hash, fee);
      
      logActivity('PAY_SUCCESS', userId, query.from.username, { 
        amount, fee, payment_hash: payment.payment_hash 
      });
      
      // Update message
      await bot.editMessageText(
        `‚úÖ *Pago Enviado*\n\n` +
        `Monto: ${amount.toLocaleString()} sats\n` +
        `Fee: ${fee.toLocaleString()} sats\n` +
        `Total: ${total.toLocaleString()} sats\n\n` +
        `Payment Hash:\n\`${payment.payment_hash}\`\n\n` +
        `Balance: ${(user.balance_sats - total).toLocaleString()} sats`,
        {
          chat_id: query.message.chat.id,
          message_id: query.message.message_id,
          parse_mode: 'Markdown'
        }
      );
      
      // Clean up
      global.pendingPayments.delete(key);
      
    } catch (error) {
      logActivity('PAY_ERROR', userId, query.from.username, { error: error.message });
      console.error('Payment error:', error);
      
      await bot.editMessageText(
        `‚ùå *Error en el Pago*\n\n` +
        `${escMd(error.message)}\n\n` +
        `Tu balance no fue afectado.`,
        {
          chat_id: query.message.chat.id,
          message_id: query.message.message_id,
          parse_mode: 'Markdown'
        }
      );
      
      global.pendingPayments.delete(key);
    }
    return;
  }
  
  // Handle giveaway claim
  if (data.startsWith('giveaway_claim:')) {
    const giveawayId = parseInt(data.split(':')[1]);
    const userId = query.from.id;
    const username = query.from.username;
    
    logActivity('GIVEAWAY_CLAIM', userId, username, { giveaway_id: giveawayId });
    
    const giveaway = db.prepare('SELECT * FROM giveaways WHERE id = ? AND status = ?').get(giveawayId, 'active');
    
    if (!giveaway) {
      return bot.answerCallbackQuery(query.id, { text: '‚ùå Este giveaway ya fue reclamado o expir√≥', show_alert: true });
    }
    
    // Giver cannot claim their own giveaway
    if (userId === giveaway.giver_telegram_id) {
      return bot.answerCallbackQuery(query.id, { text: '‚ùå No puedes reclamar tu propio giveaway', show_alert: true });
    }
    
    // Ensure claimer exists
    getOrCreateUser(userId, username);
    
    // Transfer sats atomically
    try {
      db.transaction(() => {
        // Credit claimer
        db.prepare('UPDATE users SET balance_sats = balance_sats + ? WHERE telegram_id = ?').run(giveaway.amount_sats, userId);
        db.prepare(`INSERT INTO transactions (telegram_id, type, amount_sats, description) VALUES (?, 'giveaway_claim', ?, ?)`)
          .run(userId, giveaway.amount_sats, `Giveaway de @${db.prepare('SELECT username FROM users WHERE telegram_id = ?').get(giveaway.giver_telegram_id)?.username || giveaway.giver_telegram_id}`);
        
        // Mark as claimed
        db.prepare('UPDATE giveaways SET status = ?, claimer_telegram_id = ? WHERE id = ?')
          .run('claimed', userId, giveawayId);
      })();
      
      logActivity('GIVEAWAY_CLAIMED', userId, username, { giveaway_id: giveawayId, amount: giveaway.amount_sats });
      
      await bot.answerCallbackQuery(query.id, { text: `üéÅ ¬°Ganaste ${giveaway.amount_sats} sats!` });
      
      // Update message
      try {
        await bot.editMessageText(
          `üéÅ *Giveaway Reclamado*\n\n` +
          `@${username || userId} reclam√≥ *${giveaway.amount_sats.toLocaleString()} sats*\n\n` +
          `De: @${db.prepare('SELECT username FROM users WHERE telegram_id = ?').get(giveaway.giver_telegram_id)?.username || giveaway.giver_telegram_id}`,
          {
            chat_id: giveaway.chat_id,
            message_id: giveaway.message_id,
            parse_mode: 'Markdown'
          }
        );
      } catch (e) { /* message might be old */ }
      
      // Notify claimer via DM
      try {
        await bot.sendMessage(userId,
          `üéÅ *¬°Giveaway reclamado!*\n\n` +
          `Ganaste: ${giveaway.amount_sats.toLocaleString()} sats\n` +
          `Nuevo balance: ${(db.prepare('SELECT balance_sats FROM users WHERE telegram_id = ?').get(userId).balance_sats).toLocaleString()} sats`,
          { parse_mode: 'Markdown' }
        );
      } catch (e) { /* can't DM */ }
      
    } catch (error) {
      logActivity('GIVEAWAY_CLAIM_ERROR', userId, username, { error: error.message });
      await bot.answerCallbackQuery(query.id, { text: '‚ùå Error procesando claim', show_alert: true });
    }
    return;
  }
  
  // Handle giveflip join
  if (data.startsWith('giveflip_join:')) {
    const giveflipId = parseInt(data.split(':')[1]);
    const userId = query.from.id;
    const username = query.from.username;
    
    logActivity('GIVEFLIP_JOIN', userId, username, { giveflip_id: giveflipId });
    
    const giveflip = db.prepare('SELECT * FROM giveflips WHERE id = ? AND status = ?').get(giveflipId, 'active');
    
    if (!giveflip) {
      return bot.answerCallbackQuery(query.id, { text: '‚ùå Este giveflip ya termin√≥ o expir√≥', show_alert: true });
    }
    
    // Giver cannot join their own giveflip
    if (userId === giveflip.giver_telegram_id) {
      return bot.answerCallbackQuery(query.id, { text: '‚ùå No puedes unirte a tu propio giveflip', show_alert: true });
    }
    
    // Check if already joined
    const alreadyJoined = db.prepare('SELECT * FROM giveflip_participants WHERE giveflip_id = ? AND telegram_id = ?')
      .get(giveflipId, userId);
    
    if (alreadyJoined) {
      return bot.answerCallbackQuery(query.id, { text: '‚ùå Ya est√°s participando', show_alert: true });
    }
    
    // Ensure user exists
    getOrCreateUser(userId, username);
    
    // Add participant
    db.prepare('INSERT INTO giveflip_participants (giveflip_id, telegram_id) VALUES (?, ?)').run(giveflipId, userId);
    
    const participants = db.prepare(`
      SELECT gp.*, u.username FROM giveflip_participants gp 
      LEFT JOIN users u ON gp.telegram_id = u.telegram_id 
      WHERE gp.giveflip_id = ?
    `).all(giveflipId);
    const currentCount = participants.length;
    
    logActivity('GIVEFLIP_JOINED', userId, username, { giveflip_id: giveflipId, count: currentCount });
    
    await bot.answerCallbackQuery(query.id, { text: '‚úÖ Te uniste al giveflip' });
    
    // Check if full
    if (currentCount >= giveflip.max_participants) {
      // Pick random winner
      const winnerIndex = Math.floor(Math.random() * participants.length);
      const winner = participants[winnerIndex];
      
      // Credit winner
      updateBalance(winner.telegram_id, giveflip.amount_sats, 'giveflip_win', 
        `¬°Ganaste giveflip! ${giveflip.amount_sats} sats`);
      
      // Mark as complete
      db.prepare('UPDATE giveflips SET status = ?, winner_telegram_id = ? WHERE id = ?')
        .run('completed', winner.telegram_id, giveflipId);
      
      const participantList = participants.map(p => `@${p.username || p.telegram_id}`).join(', ');
      
      logActivity('GIVEFLIP_WINNER', winner.telegram_id, winner.username, { 
        giveflip_id: giveflipId, 
        amount: giveflip.amount_sats,
        participants: currentCount 
      });
      
      // Update message
      try {
        await bot.editMessageText(
          `üé≤ *¬°Giveflip Completado!*\n\n` +
          `üèÜ Ganador: @${winner.username || winner.telegram_id}\n\n` +
          `Premio: ${giveflip.amount_sats.toLocaleString()} sats\n` +
          `Participantes: ${participantList}`,
          {
            chat_id: giveflip.chat_id,
            message_id: giveflip.message_id,
            parse_mode: 'Markdown'
          }
        );
      } catch (e) { /* message might be old */ }
      
      // Notify winner via DM
      try {
        await bot.sendMessage(winner.telegram_id,
          `üèÜ *¬°Ganaste el giveflip!*\n\n` +
          `Premio: ${giveflip.amount_sats.toLocaleString()} sats\n` +
          `Nuevo balance: ${(db.prepare('SELECT balance_sats FROM users WHERE telegram_id = ?').get(winner.telegram_id).balance_sats).toLocaleString()} sats`,
          { parse_mode: 'Markdown' }
        );
      } catch (e) { /* can't DM */ }
      
    } else {
      // Update message with progress
      const participantList = participants.map(p => `  ‚Ä¢ @${p.username || p.telegram_id}`).join('\n');
      try {
        await bot.editMessageText(
          `üé≤ *¬°Giveflip!*\n\n` +
          `De: @${db.prepare('SELECT username FROM users WHERE telegram_id = ?').get(giveflip.giver_telegram_id)?.username || giveflip.giver_telegram_id}\n` +
          `Premio: ${giveflip.amount_sats.toLocaleString()} sats\n\n` +
          `Participantes: ${currentCount}/${giveflip.max_participants}\n` +
          `${participantList}\n\n` +
          `_Un ganador aleatorio se lleva todo_\n` +
          `_Expira en 10 minutos_`,
          {
            chat_id: giveflip.chat_id,
            message_id: giveflip.message_id,
            parse_mode: 'Markdown',
            reply_markup: {
              inline_keyboard: [[
                { text: 'üé≤ Participar', callback_data: `giveflip_join:${giveflipId}` }
              ]]
            }
          }
        );
      } catch (e) { /* message might be old */ }
    }
    return;
  }
  
  // Handle fundraise contribution
  if (data.startsWith('fundraise_contribute:')) {
    const fundraiseId = parseInt(data.split(':')[1]);
    const userId = query.from.id;
    const username = query.from.username;
    
    logActivity('FUNDRAISE_CONTRIBUTE', userId, username, { fundraise_id: fundraiseId });
    
    const fundraise = db.prepare('SELECT * FROM fundraises WHERE id = ? AND status = ?').get(fundraiseId, 'active');
    
    if (!fundraise) {
      return bot.answerCallbackQuery(query.id, { text: '‚ùå Esta fundraise ya termin√≥ o expir√≥', show_alert: true });
    }
    
    // Check if already contributed
    const alreadyContributed = db.prepare('SELECT * FROM fundraise_contributors WHERE fundraise_id = ? AND telegram_id = ?')
      .get(fundraiseId, userId);
    
    if (alreadyContributed) {
      return bot.answerCallbackQuery(query.id, { text: '‚ùå Ya contribuiste a esta fundraise', show_alert: true });
    }
    
    const user = getOrCreateUser(userId, username);
    
    if (user.balance_sats < fundraise.amount_per_person) {
      return bot.answerCallbackQuery(query.id, { 
        text: `‚ùå Necesitas ${fundraise.amount_per_person} sats (tienes ${user.balance_sats})`, 
        show_alert: true 
      });
    }
    
    // Deduct contribution
    updateBalance(userId, -fundraise.amount_per_person, 'fundraise_contribute',
      `Fundraise para @${fundraise.recipient_username || fundraise.recipient_telegram_id}: ${fundraise.amount_per_person} sats`);
    
    // Add contributor
    db.prepare('INSERT INTO fundraise_contributors (fundraise_id, telegram_id) VALUES (?, ?)').run(fundraiseId, userId);
    
    const contributors = db.prepare(`
      SELECT fc.*, u.username FROM fundraise_contributors fc 
      LEFT JOIN users u ON fc.telegram_id = u.telegram_id 
      WHERE fc.fundraise_id = ?
    `).all(fundraiseId);
    const currentCount = contributors.length;
    
    logActivity('FUNDRAISE_CONTRIBUTED', userId, username, { 
      fundraise_id: fundraiseId, 
      amount: fundraise.amount_per_person,
      count: currentCount 
    });
    
    await bot.answerCallbackQuery(query.id, { text: `‚úÖ Contribuiste ${fundraise.amount_per_person} sats` });
    
    // Check if goal reached
    if (currentCount >= fundraise.max_participants) {
      const totalRaised = fundraise.amount_per_person * fundraise.max_participants;
      
      // Transfer to recipient
      updateBalance(fundraise.recipient_telegram_id, totalRaised, 'fundraise_received',
        `Fundraise completada: ${currentCount} personas x ${fundraise.amount_per_person} sats`);
      
      // Mark as complete
      db.prepare('UPDATE fundraises SET status = ? WHERE id = ?').run('completed', fundraiseId);
      
      const contributorList = contributors.map(c => `  ‚Ä¢ @${c.username || c.telegram_id}`).join('\n');
      
      logActivity('FUNDRAISE_COMPLETED', fundraise.recipient_telegram_id, fundraise.recipient_username, { 
        fundraise_id: fundraiseId, 
        total: totalRaised,
        contributors: currentCount 
      });
      
      // Update message
      try {
        await bot.editMessageText(
          `üí∞ *¬°Fundraise Completada!*\n\n` +
          `Para: @${fundraise.recipient_username || fundraise.recipient_telegram_id}\n` +
          `Total recaudado: ${totalRaised.toLocaleString()} sats\n\n` +
          `Contribuyentes:\n${contributorList}\n\n` +
          `¬°Gracias a todos! üôè`,
          {
            chat_id: fundraise.chat_id,
            message_id: fundraise.message_id,
            parse_mode: 'Markdown'
          }
        );
      } catch (e) { /* message might be old */ }
      
      // Notify recipient via DM
      try {
        await bot.sendMessage(fundraise.recipient_telegram_id,
          `üí∞ *¬°Fundraise completada!*\n\n` +
          `Recibiste: ${totalRaised.toLocaleString()} sats\n` +
          `De ${currentCount} personas (${fundraise.amount_per_person.toLocaleString()} sats c/u)\n\n` +
          `Nuevo balance: ${(db.prepare('SELECT balance_sats FROM users WHERE telegram_id = ?').get(fundraise.recipient_telegram_id).balance_sats).toLocaleString()} sats`,
          { parse_mode: 'Markdown' }
        );
      } catch (e) { /* can't DM */ }
      
    } else {
      // Update message with progress
      const contributorList = contributors.map(c => `  ‚Ä¢ @${c.username || c.telegram_id} ‚úÖ`).join('\n');
      const totalGoal = fundraise.amount_per_person * fundraise.max_participants;
      const currentTotal = fundraise.amount_per_person * currentCount;
      
      try {
        await bot.editMessageText(
          `üí∞ *¬°Fundraise!*\n\n` +
          `Para: @${fundraise.recipient_username || fundraise.recipient_telegram_id}\n` +
          `Meta: ${totalGoal.toLocaleString()} sats\n` +
          `Recaudado: ${currentTotal.toLocaleString()} sats\n\n` +
          `Contribuyentes: ${currentCount}/${fundraise.max_participants}\n` +
          `${contributorList}\n\n` +
          `Aporte: ${fundraise.amount_per_person.toLocaleString()} sats por persona\n` +
          `_Expira en 30 minutos_`,
          {
            chat_id: fundraise.chat_id,
            message_id: fundraise.message_id,
            parse_mode: 'Markdown',
            reply_markup: {
              inline_keyboard: [[
                { text: `üí∞ Contribuir ${fundraise.amount_per_person.toLocaleString()} sats`, callback_data: `fundraise_contribute:${fundraiseId}` }
              ]]
            }
          }
        );
      } catch (e) { /* message might be old */ }
    }
    return;
  }
  
  // Handle coinflip joins
  if (data.startsWith('coinflip_join:')) {
    const coinflipId = parseInt(data.split(':')[1]);
    const userId = query.from.id;
    const username = query.from.username;
    
    logActivity('COINFLIP_JOIN_ATTEMPT', userId, username, { coinflip_id: coinflipId });
    
    const flip = db.prepare('SELECT * FROM coinflips WHERE id = ? AND active = 1').get(coinflipId);
    if (!flip) {
      return bot.answerCallbackQuery(query.id, { text: '‚ùå Este coinflip ya termin√≥', show_alert: true });
    }
    
    // Check if already joined
    const already = db.prepare('SELECT * FROM coinflip_participants WHERE coinflip_id = ? AND telegram_id = ?').get(coinflipId, userId);
    if (already) {
      return bot.answerCallbackQuery(query.id, { text: '‚ùå Ya est√°s en este coinflip', show_alert: true });
    }
    
    // Check balance
    const user = getOrCreateUser(userId, username);
    if (user.balance_sats < flip.bet_sats) {
      return bot.answerCallbackQuery(query.id, { text: `‚ùå Necesitas ${flip.bet_sats} sats (tienes ${user.balance_sats})`, show_alert: true });
    }
    
    // Deduct bet
    updateBalance(userId, -flip.bet_sats, 'coinflip_bet', `Coinflip #${coinflipId}: ${flip.bet_sats} sats`);
    
    // Add participant
    db.prepare('INSERT INTO coinflip_participants (coinflip_id, telegram_id) VALUES (?, ?)').run(coinflipId, userId);
    
    const participants = db.prepare('SELECT cp.*, u.username FROM coinflip_participants cp LEFT JOIN users u ON cp.telegram_id = u.telegram_id WHERE cp.coinflip_id = ?').all(coinflipId);
    const currentCount = participants.length;
    const pot = flip.bet_sats * flip.max_participants;
    
    logActivity('COINFLIP_JOINED', userId, username, { coinflip_id: coinflipId, count: currentCount });
    
    await bot.answerCallbackQuery(query.id, { text: `‚úÖ Te uniste! Apuesta: ${flip.bet_sats} sats` });
    
    // Check if full
    if (currentCount >= flip.max_participants) {
      // Pick random winner
      const winnerIndex = Math.floor(Math.random() * participants.length);
      const winner = participants[winnerIndex];
      
      // Credit winner
      updateBalance(winner.telegram_id, pot, 'coinflip_win', `¬°Ganaste coinflip #${coinflipId}! Bote: ${pot} sats`);
      
      // Mark as complete
      db.prepare('UPDATE coinflips SET active = 0, winner_telegram_id = ? WHERE id = ?').run(winner.telegram_id, coinflipId);
      
      const participantList = participants.map(p => `@${p.username || p.telegram_id}`).join(', ');
      
      logActivity('COINFLIP_WINNER', winner.telegram_id, winner.username, { coinflip_id: coinflipId, pot, participants: currentCount });
      
      // Update message
      try {
        await bot.editMessageText(
          `üé∞ *Coinflip #${coinflipId} ‚Äî ¬°TERMINADO!*\n\n` +
          `üèÜ *Ganador: @${winner.username || winner.telegram_id}*\n\n` +
          `Bote: ${pot.toLocaleString()} sats\n` +
          `Participantes: ${participantList}\n\n` +
          `_Cada uno apost√≥ ${flip.bet_sats.toLocaleString()} sats_`,
          {
            chat_id: flip.chat_id,
            message_id: flip.message_id,
            parse_mode: 'Markdown'
          }
        );
      } catch (e) {
        // Send new message if edit fails
        await bot.sendMessage(flip.chat_id,
          `üé∞üèÜ *¬°@${winner.username || winner.telegram_id} gan√≥ ${pot.toLocaleString()} sats!*\n\n` +
          `Coinflip #${coinflipId} | Participantes: ${participantList}`,
          { parse_mode: 'Markdown' }
        );
      }
      
      // Notify winner via DM
      try {
        await bot.sendMessage(winner.telegram_id,
          `üèÜ *¬°Ganaste el coinflip #${coinflipId}!*\n\n` +
          `Bote: ${pot.toLocaleString()} sats\n` +
          `Nuevo balance: ${(user.balance_sats + pot).toLocaleString()} sats`
        , { parse_mode: 'Markdown' });
      } catch (e) { /* can't DM winner */ }
    } else {
      // Update message with new participant count
      const participantList = participants.map(p => `@${p.username || p.telegram_id}`).join('\n');
      try {
        await bot.editMessageText(
          `üé∞ *¬°Coinflip #${coinflipId}!*\n\n` +
          `Apuesta: ${flip.bet_sats.toLocaleString()} sats\n` +
          `Bote: ${pot.toLocaleString()} sats\n` +
          `Participantes: ${currentCount}/${flip.max_participants}\n\n` +
          `${participantList}\n\n` +
          `_Usa el bot√≥n para unirte!_`,
          {
            chat_id: flip.chat_id,
            message_id: flip.message_id,
            parse_mode: 'Markdown',
            reply_markup: {
              inline_keyboard: [[
                { text: `üé∞ Unirse (${flip.bet_sats} sats)`, callback_data: `coinflip_join:${coinflipId}` }
              ]]
            }
          }
        );
      } catch (e) { console.error('Could not update coinflip message:', e.message); }
    }
    return;
  }
  
  // Handle hidden message reveal
  if (data.startsWith('reveal:')) {
    const hiddenId = parseInt(data.split(':')[1]);
    const userId = query.from.id;
    const username = query.from.username;
    
    logActivity('REVEAL_ATTEMPT', userId, username, { hidden_id: hiddenId });
    
    const hidden = db.prepare('SELECT * FROM hidden_messages WHERE id = ?').get(hiddenId);
    if (!hidden) {
      return bot.answerCallbackQuery(query.id, { text: '‚ùå Mensaje no encontrado', show_alert: true });
    }
    
    // Creator can reveal for free
    if (userId === hidden.creator_telegram_id) {
      await bot.answerCallbackQuery(query.id, { text: 'üëÄ Tu propio mensaje' });
      return bot.sendMessage(userId, `üîì Tu mensaje oculto #${hiddenId}:\n\n${hidden.content}`);
    }
    
    // Check if already revealed
    const alreadyRevealed = db.prepare('SELECT * FROM message_reveals WHERE hidden_id = ? AND telegram_id = ?').get(hiddenId, userId);
    if (alreadyRevealed) {
      await bot.answerCallbackQuery(query.id, { text: '‚úÖ Ya lo revelaste' });
      return bot.sendMessage(userId, `üîì Mensaje oculto #${hiddenId}:\n\n${hidden.content}`);
    }
    
    // Check balance
    const user = getOrCreateUser(userId, username);
    if (user.balance_sats < hidden.price_sats) {
      return bot.answerCallbackQuery(query.id, { text: `‚ùå Necesitas ${hidden.price_sats} sats (tienes ${user.balance_sats})`, show_alert: true });
    }
    
    // Transfer payment (atomic)
    try {
      db.transaction(() => {
        // Deduct from revealer
        db.prepare('UPDATE users SET balance_sats = balance_sats - ? WHERE telegram_id = ?').run(hidden.price_sats, userId);
        db.prepare(`INSERT INTO transactions (telegram_id, type, amount_sats, description) VALUES (?, 'reveal_pay', ?, ?)`)
          .run(userId, -hidden.price_sats, `Revelar mensaje #${hiddenId}`);
        
        // Credit creator
        db.prepare('UPDATE users SET balance_sats = balance_sats + ? WHERE telegram_id = ?').run(hidden.price_sats, hidden.creator_telegram_id);
        db.prepare(`INSERT INTO transactions (telegram_id, type, amount_sats, description) VALUES (?, 'reveal_income', ?, ?)`)
          .run(hidden.creator_telegram_id, hidden.price_sats, `Mensaje #${hiddenId} revelado por ${username || userId}`);
        

[Showing lines 1348-2674 of 3171 (50.0KB limit). Use offset=2675 to continue.]

---

### ü§ñ **Claudio** [18:31:21]

// Record reveal
        db.prepare('INSERT INTO message_reveals (hidden_id, telegram_id) VALUES (?, ?)').run(hiddenId, userId);
        
        // Update reveal count
        db.prepare('UPDATE hidden_messages SET reveals = reveals + 1 WHERE id = ?').run(hiddenId);
      })();
      
      logActivity('REVEAL_OK', userId, username, { hidden_id: hiddenId, price: hidden.price_sats });
      
      await bot.answerCallbackQuery(query.id, { text: `‚úÖ Pagaste ${hidden.price_sats} sats ‚Äî mensaje enviado por DM` });
      
      // Send message content via DM
      await bot.sendMessage(userId,
        `üîì *Mensaje oculto #${hiddenId}*\n\n` +
        `${hidden.content}\n\n` +
        `_Pagaste ${hidden.price_sats} sats para revelarlo_`,
        { parse_mode: 'Markdown' }
      );
      
      // Update public message with reveal count
      const updated = db.prepare('SELECT reveals FROM hidden_messages WHERE id = ?').get(hiddenId);
      try {
        await bot.editMessageText(
          `üîí *Mensaje Oculto #${hiddenId}*\n\n` +
          `Precio: ${hidden.price_sats.toLocaleString()} sats\n` +
          `Revelado por: ${updated.reveals} persona(s)\n\n` +
          `_Paga para ver el contenido_`,
          {
            chat_id: hidden.chat_id,
            message_id: hidden.message_id,
            parse_mode: 'Markdown',
            reply_markup: {
              inline_keyboard: [[
                { text: `üîì Revelar (${hidden.price_sats} sats)`, callback_data: `reveal:${hiddenId}` }
              ]]
            }
          }
        );
      } catch (e) { /* edit might fail, that's ok */ }
      
    } catch (error) {
      logActivity('REVEAL_ERROR', userId, username, { error: error.message });
      await bot.answerCallbackQuery(query.id, { text: '‚ùå Error procesando pago', show_alert: true });
    }
    return;
  }
});

// === HIDDEN MESSAGES SYSTEM ===

db.exec(`
  CREATE TABLE IF NOT EXISTS hidden_messages (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    creator_telegram_id INTEGER NOT NULL,
    chat_id INTEGER NOT NULL,
    message_id INTEGER,
    content TEXT NOT NULL,
    price_sats INTEGER NOT NULL,
    reveals INTEGER DEFAULT 0,
    created_at INTEGER DEFAULT (strftime('%s', 'now')),
    FOREIGN KEY (creator_telegram_id) REFERENCES users(telegram_id)
  );
  
  CREATE TABLE IF NOT EXISTS message_reveals (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    hidden_id INTEGER NOT NULL,
    telegram_id INTEGER NOT NULL,
    created_at INTEGER DEFAULT (strftime('%s', 'now')),
    FOREIGN KEY (hidden_id) REFERENCES hidden_messages(id),
    FOREIGN KEY (telegram_id) REFERENCES users(telegram_id),
    UNIQUE(hidden_id, telegram_id)
  );
`);

bot.onText(/\/hide\s+(\d+)\s+(.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const priceSats = parseInt(match[1]);
  const content = match[2].trim();
  
  logActivity('HIDE_CREATE', userId, msg.from.username, { chat_id: chatId, price: priceSats, content_len: content.length });
  
  if (priceSats < 1) return bot.sendMessage(chatId, '‚ùå Precio m√≠nimo: 1 sat');
  if (priceSats > 1_000_000) return bot.sendMessage(chatId, '‚ùå Precio m√°ximo: 1,000,000 sats');
  if (content.length > 4000) return bot.sendMessage(chatId, '‚ùå Mensaje demasiado largo (m√°x 4000 chars)');
  
  getOrCreateUser(userId, msg.from.username);
  
  // Delete the original message to hide the content
  try {
    await bot.deleteMessage(chatId, msg.message_id);
  } catch (e) { /* might not have permission */ }
  
  const result = db.prepare(`
    INSERT INTO hidden_messages (creator_telegram_id, chat_id, content, price_sats) VALUES (?, ?, ?, ?)
  `).run(userId, chatId, content, priceSats);
  const hiddenId = result.lastInsertRowid;
  
  const sentMsg = await bot.sendMessage(chatId,
    `üîí *Mensaje Oculto #${hiddenId}*\n\n` +
    `De: @${msg.from.username || userId}\n` +
    `Precio: ${priceSats.toLocaleString()} sats\n` +
    `Revelado por: 0 persona(s)\n\n` +
    `_Paga para ver el contenido_`,
    {
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: [[
          { text: `üîì Revelar (${priceSats} sats)`, callback_data: `reveal:${hiddenId}` }
        ]]
      }
    }
  );
  
  // Store message_id for later updates
  db.prepare('UPDATE hidden_messages SET message_id = ? WHERE id = ?').run(sentMsg.message_id, hiddenId);
  
  logActivity('HIDE_CREATED', userId, msg.from.username, { hidden_id: hiddenId, price: priceSats });
});

// /reveal command (alternative to button)
bot.onText(/\/reveal\s+(\d+)/, async (msg, match) => {
  const userId = msg.from.id;
  const hiddenId = parseInt(match[1]);
  
  const hidden = db.prepare('SELECT * FROM hidden_messages WHERE id = ?').get(hiddenId);
  if (!hidden) {
    return bot.sendMessage(userId, '‚ùå Mensaje oculto no encontrado.');
  }
  
  // Creator sees for free
  if (userId === hidden.creator_telegram_id) {
    return bot.sendMessage(userId, `üîì Tu mensaje oculto #${hiddenId}:\n\n${hidden.content}`);
  }
  
  // Check already revealed
  const alreadyRevealed = db.prepare('SELECT * FROM message_reveals WHERE hidden_id = ? AND telegram_id = ?').get(hiddenId, userId);
  if (alreadyRevealed) {
    return bot.sendMessage(userId, `üîì Mensaje oculto #${hiddenId}:\n\n${hidden.content}`);
  }
  
  const user = getOrCreateUser(userId, msg.from.username);
  if (user.balance_sats < hidden.price_sats) {
    return bot.sendMessage(userId, `‚ùå Necesitas ${hidden.price_sats} sats (tienes ${user.balance_sats})`);
  }
  
  // Execute payment
  try {
    db.transaction(() => {
      db.prepare('UPDATE users SET balance_sats = balance_sats - ? WHERE telegram_id = ?').run(hidden.price_sats, userId);
      db.prepare(`INSERT INTO transactions (telegram_id, type, amount_sats, description) VALUES (?, 'reveal_pay', ?, ?)`)
        .run(userId, -hidden.price_sats, `Revelar mensaje #${hiddenId}`);
      db.prepare('UPDATE users SET balance_sats = balance_sats + ? WHERE telegram_id = ?').run(hidden.price_sats, hidden.creator_telegram_id);
      db.prepare(`INSERT INTO transactions (telegram_id, type, amount_sats, description) VALUES (?, 'reveal_income', ?, ?)`)
        .run(hidden.creator_telegram_id, hidden.price_sats, `Mensaje #${hiddenId} revelado`);
      db.prepare('INSERT INTO message_reveals (hidden_id, telegram_id) VALUES (?, ?)').run(hiddenId, userId);
      db.prepare('UPDATE hidden_messages SET reveals = reveals + 1 WHERE id = ?').run(hiddenId);
    })();
    
    logActivity('REVEAL_CMD_OK', userId, msg.from.username, { hidden_id: hiddenId, price: hidden.price_sats });
    
    await bot.sendMessage(userId,
      `üîì *Mensaje oculto #${hiddenId}*\n\n${hidden.content}\n\n_Pagaste ${hidden.price_sats} sats_`,
      { parse_mode: 'Markdown' }
    );
  } catch (error) {
    await bot.sendMessage(userId, '‚ùå Error procesando pago.');
  }
});

// === CALCULATOR ===
bot.onText(/\/calc\s+(.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const input = match[1].trim();
  logActivity('CALC', msg.from.id, msg.from.username, { input });
  
  try {
    // Fetch BTC price from CoinGecko
    const fetch = (await import('node-fetch')).default;
    const res = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd');
    const data = await res.json();
    const btcPrice = data.bitcoin.usd;
    
    let result;
    
    if (input.startsWith('$') || input.toLowerCase().includes('usd')) {
      // USD to sats
      const usd = parseFloat(input.replace(/[$usd\s]/gi, ''));
      if (isNaN(usd) || usd <= 0) return bot.sendMessage(chatId, '‚ùå Cantidad inv√°lida');
      const sats = Math.round((usd / btcPrice) * 100_000_000);
      result = `üí± $${usd.toFixed(2)} USD = *${sats.toLocaleString()} sats*\n\n` +
        `BTC price: $${btcPrice.toLocaleString()}`;
    } else {
      // Sats to USD
      const sats = parseInt(input.replace(/[,.\s]/g, ''));
      if (isNaN(sats) || sats <= 0) return bot.sendMessage(chatId, '‚ùå Cantidad inv√°lida');
      const usd = (sats / 100_000_000) * btcPrice;
      result = `üí± *${sats.toLocaleString()} sats* = $${usd.toFixed(2)} USD\n\n` +
        `BTC price: $${btcPrice.toLocaleString()}`;
    }
    
    await bot.sendMessage(chatId, result, { parse_mode: 'Markdown' });
  } catch (error) {
    console.error('Calc error:', error);
    await bot.sendMessage(chatId, '‚ùå Error obteniendo precio de BTC');
  }
});

// Invoice settlement monitor
async function monitorInvoices() {
  // Check deposit invoices
  const pending = db.prepare('SELECT * FROM pending_invoices').all();
  
  for (const invoice of pending) {
    try {
      // Convert base64 r_hash to hex for LND API
      const hexHash = Buffer.from(invoice.payment_hash, 'base64').toString('hex');
      const result = await lndRequest('GET', `/v1/invoice/${hexHash}`);
      
      if (result.settled) {
        // Credit user account
        updateBalance(invoice.telegram_id, invoice.amount_sats, 'deposit', 
          'Lightning deposit', invoice.payment_hash, 0);
        
        logActivity('DEPOSIT_SETTLED', invoice.telegram_id, null, { amount: invoice.amount_sats });
        
        // Remove from pending
        db.prepare('DELETE FROM pending_invoices WHERE payment_hash = ?')
          .run(invoice.payment_hash);
        
        // Notify user
        await bot.sendMessage(invoice.telegram_id,
          `‚úÖ Dep√≥sito recibido: ${invoice.amount_sats} sats\n` +
          `Balance: ${db.prepare('SELECT balance_sats FROM users WHERE telegram_id = ?').get(invoice.telegram_id).balance_sats} sats`
        );
      }
    } catch (error) {
      // Invoice might not exist yet, skip
    }
  }
  
  // Check group join ticket invoices
  const pendingJoins = db.prepare(`
    SELECT * FROM group_join_requests 
    WHERE status = 'pending'
  `).all();
  
  for (const joinReq of pendingJoins) {
    try {
      // Convert base64 r_hash to hex for LND API
      const hexHash = Buffer.from(joinReq.payment_hash, 'base64').toString('hex');
      const result = await lndRequest('GET', `/v1/invoice/${hexHash}`);
      const now = Math.floor(Date.now() / 1000);
      const age = now - joinReq.created_at;
      
      if (result.settled) {
        // Payment received - try to approve join request OR create invite link
        try {
          // First, try to approve join request (old method: user clicked "Request to Join")
          let approved = false;
          try {
            await bot.approveChatJoinRequest(joinReq.chat_id, joinReq.telegram_id);
            approved = true;
            
            // Notify user
            await bot.sendMessage(joinReq.telegram_id,
              `‚úÖ Pago recibido - Solicitud de uni√≥n aprobada\n\n` +
              `Ya puedes acceder al grupo.`
            );
            
            logActivity('JOIN_APPROVED', joinReq.telegram_id, null, { chat_id: joinReq.chat_id, amount: joinReq.amount_sats });
          } catch (approveError) {
            // No pending join request - user must have used /join command
            // Create single-use invite link instead
            if (approveError.message.includes('USER_ALREADY_PARTICIPANT') || 
                approveError.message.includes('HIDE_REQUESTER_MISSING')) {
              
              const inviteLink = await bot.createChatInviteLink(joinReq.chat_id, {
                member_limit: 1,  // Single-use link
                name: `Ticket pagado - ${joinReq.telegram_id}`,
                expire_date: Math.floor(Date.now() / 1000) + 3600  // 1 hour expiry
              });
              
              approved = true;
              
              // Send invite link to user
              await bot.sendMessage(joinReq.telegram_id,
                `‚úÖ Pago recibido\n\n` +
                `Aqu√≠ est√° tu enlace de invitaci√≥n de un solo uso:\n\n` +
                `${inviteLink.invite_link}\n\n` +
                `_Expira en 1 hora. Haz click para unirte al grupo._`
              );
              
              logActivity('INVITE_LINK_CREATED', joinReq.telegram_id, null, { chat_id: joinReq.chat_id, amount: joinReq.amount_sats });
            } else {
              throw approveError;  // Some other error - re-throw
            }
          }
          
          if (approved) {
            // Update status
            db.prepare('UPDATE group_join_requests SET status = ? WHERE id = ?')
              .run('approved', joinReq.id);
            
            // Credit revenue (no user credit - direct payment for service)
            db.prepare(`
              INSERT INTO transactions (telegram_id, type, amount_sats, fee_sats, description)
              VALUES (?, ?, ?, ?, ?)
            `).run(
              joinReq.telegram_id, 
              'group_ticket', 
              joinReq.amount_sats,
              0,
              `Ticket pagado: grupo ${joinReq.chat_id}`
            );
          }
        } catch (approveError) {
          console.error('Error processing paid join request:', approveError);
          
          // Mark as error but don't delete (for audit)
          db.prepare('UPDATE group_join_requests SET status = ? WHERE id = ?')
            .run('error', joinReq.id);
        }
      } else if (age > GROUP_JOIN_TIMEOUT_SECONDS) {
        // Timeout - decline request
        try {
          await bot.declineChatJoinRequest(joinReq.chat_id, joinReq.telegram_id);
          
          // Update status
          db.prepare('UPDATE group_join_requests SET status = ? WHERE id = ?')
            .run('expired', joinReq.id);
          
          // Notify user
          await bot.sendMessage(joinReq.telegram_id,
            `‚è±Ô∏è Ticket expirado\n\n` +
            `Tu solicitud de uni√≥n al grupo fue rechazada por falta de pago.\n` +
            `Puedes intentar de nuevo.`
          );
          
          logActivity('JOIN_EXPIRED', joinReq.telegram_id, null, { chat_id: joinReq.chat_id });
        } catch (declineError) {
          console.error('Error declining expired request:', declineError);
          
          // Mark as expired anyway
          db.prepare('UPDATE group_join_requests SET status = ? WHERE id = ?')
            .run('expired', joinReq.id);
        }
      }
    } catch (error) {
      // Invoice might not exist yet, skip
      console.error('Error checking join request invoice:', error.message);
    }
  }
}

// Start invoice monitor (every 10 seconds)
setInterval(monitorInvoices, 10000);

// === CLEANUP: Expired invoices and stale coinflips ===
async function cleanupExpired() {
  const now = Math.floor(Date.now() / 1000);
  
  // Clean expired pending invoices (>1 hour old)
  const expiredInvoices = db.prepare('SELECT * FROM pending_invoices WHERE created_at < ?').all(now - 3600);
  if (expiredInvoices.length > 0) {
    db.prepare('DELETE FROM pending_invoices WHERE created_at < ?').run(now - 3600);
    logActivity('CLEANUP_INVOICES', null, null, { count: expiredInvoices.length });
  }
  
  // Clean stale coinflips (>30 minutes old, still active)
  const staleCoinflips = db.prepare('SELECT * FROM coinflips WHERE active = 1 AND created_at < ?').all(now - 1800);
  for (const flip of staleCoinflips) {
    // Refund all participants
    const participants = db.prepare('SELECT * FROM coinflip_participants WHERE coinflip_id = ?').all(flip.id);
    for (const p of participants) {
      updateBalance(p.telegram_id, flip.bet_sats, 'coinflip_refund', `Coinflip #${flip.id} expirado ‚Äî reembolso`);
      try {
        await bot.sendMessage(p.telegram_id, `üîÑ Coinflip #${flip.id} expirado. Reembolso: ${flip.bet_sats} sats`);
      } catch (e) { /* can't DM */ }
    }
    db.prepare('UPDATE coinflips SET active = 0 WHERE id = ?').run(flip.id);
    
    // Update message
    try {
      await bot.editMessageText(
        `üé∞ *Coinflip #${flip.id} ‚Äî EXPIRADO*\n\n` +
        `No se complet√≥ a tiempo. Todos los participantes fueron reembolsados.`,
        { chat_id: flip.chat_id, message_id: flip.message_id, parse_mode: 'Markdown' }
      );
    } catch (e) { /* message might be old */ }
    
    logActivity('COINFLIP_EXPIRED', null, null, { coinflip_id: flip.id, refunded: participants.length });
  }
  
  // Clean expired giveaways (refund to giver)
  const expiredGiveaways = db.prepare('SELECT * FROM giveaways WHERE status = ? AND expires_at < ?').all('active', now);
  for (const giveaway of expiredGiveaways) {
    // Refund giver
    updateBalance(giveaway.giver_telegram_id, giveaway.amount_sats, 'giveaway_refund', 
      `Giveaway #${giveaway.id} expirado ‚Äî reembolso`);
    
    db.prepare('UPDATE giveaways SET status = ? WHERE id = ?').run('expired', giveaway.id);
    
    try {
      await bot.sendMessage(giveaway.giver_telegram_id, 
        `‚è±Ô∏è Tu giveaway #${giveaway.id} expir√≥ sin reclamantes. Reembolso: ${giveaway.amount_sats} sats`);
    } catch (e) { /* can't DM */ }
    
    // Update message
    try {
      await bot.editMessageText(
        `üéÅ *Giveaway #${giveaway.id} ‚Äî EXPIRADO*\n\n` +
        `Nadie lo reclam√≥ a tiempo.`,
        { chat_id: giveaway.chat_id, message_id: giveaway.message_id, parse_mode: 'Markdown' }
      );
    } catch (e) { /* message might be old */ }
    
    logActivity('GIVEAWAY_EXPIRED', null, null, { giveaway_id: giveaway.id, refunded: giveaway.amount_sats });
  }
  
  // Clean expired giveflips (refund to giver if incomplete)
  const expiredGiveflips = db.prepare('SELECT * FROM giveflips WHERE status = ? AND expires_at < ?').all('active', now);
  for (const giveflip of expiredGiveflips) {
    // Refund giver
    updateBalance(giveflip.giver_telegram_id, giveflip.amount_sats, 'giveflip_refund', 
      `Giveflip #${giveflip.id} expirado ‚Äî reembolso`);
    
    db.prepare('UPDATE giveflips SET status = ? WHERE id = ?').run('expired', giveflip.id);
    
    const participantCount = db.prepare('SELECT COUNT(*) as count FROM giveflip_participants WHERE giveflip_id = ?')
      .get(giveflip.id).count;
    
    try {
      await bot.sendMessage(giveflip.giver_telegram_id, 
        `‚è±Ô∏è Tu giveflip #${giveflip.id} expir√≥ sin completarse (${participantCount}/${giveflip.max_participants}). Reembolso: ${giveflip.amount_sats} sats`);
    } catch (e) { /* can't DM */ }
    
    // Update message
    try {
      await bot.editMessageText(
        `üé≤ *Giveflip #${giveflip.id} ‚Äî EXPIRADO*\n\n` +
        `No se complet√≥ a tiempo (${participantCount}/${giveflip.max_participants} participantes).`,
        { chat_id: giveflip.chat_id, message_id: giveflip.message_id, parse_mode: 'Markdown' }
      );
    } catch (e) { /* message might be old */ }
    
    logActivity('GIVEFLIP_EXPIRED', null, null, { giveflip_id: giveflip.id, refunded: giveflip.amount_sats });
  }
  
  // Clean expired fundraises (refund all contributors)
  const expiredFundraises = db.prepare('SELECT * FROM fundraises WHERE status = ? AND expires_at < ?').all('active', now);
  for (const fundraise of expiredFundraises) {
    const contributors = db.prepare('SELECT * FROM fundraise_contributors WHERE fundraise_id = ?').all(fundraise.id);
    
    // Refund each contributor
    for (const contributor of contributors) {
      updateBalance(contributor.telegram_id, fundraise.amount_per_person, 'fundraise_refund',
        `Fundraise #${fundraise.id} expirada ‚Äî reembolso`);
      
      try {
        await bot.sendMessage(contributor.telegram_id,
          `‚è±Ô∏è Fundraise #${fundraise.id} expir√≥ sin completarse. Reembolso: ${fundraise.amount_per_person} sats`);
      } catch (e) { /* can't DM */ }
    }
    
    db.prepare('UPDATE fundraises SET status = ? WHERE id = ?').run('expired', fundraise.id);
    
    // Update message
    try {
      await bot.editMessageText(
        `üí∞ *Fundraise #${fundraise.id} ‚Äî EXPIRADA*\n\n` +
        `No se complet√≥ a tiempo (${contributors.length}/${fundraise.max_participants} contribuyentes).\n` +
        `Todos los contribuyentes fueron reembolsados.`,
        { chat_id: fundraise.chat_id, message_id: fundraise.message_id, parse_mode: 'Markdown' }
      );
    } catch (e) { /* message might be old */ }
    
    logActivity('FUNDRAISE_EXPIRED', null, null, { 
      fundraise_id: fundraise.id, 
      contributors: contributors.length,
      refunded_total: fundraise.amount_per_person * contributors.length
    });
  }
}

// Run cleanup every 5 minutes
setInterval(cleanupExpired, 300_000);

console.log('‚ö° Lightning Telegram Bot started');
console.log(`Bot: @Lightningeasybot`);
console.log(`LND: ${LND_REST_HOST}`);

// Handle polling errors (don't crash on errors)
bot.on('polling_error', (error) => {
  console.error('Polling error:', error.message);
});

---

### ü§ñ **Claudio** [18:31:34]

Now I've read the entire bot.js file. This is indeed massive (3171 lines) with many user-facing strings. Let me implement the comprehensive i18n system step by step.

## Step 1: Create the i18n module

---

### ü§ñ **Claudio** [18:31:34]

Successfully wrote 1115 bytes to /home/neo/lightning-telegram-bot/i18n.js

---

### ü§ñ **Claudio** [18:31:38]

## Step 2: Create locales directory and Spanish locale file (extracting ALL strings)

---

### ü§ñ **Claudio** [18:31:38]

(no output)

---

### ü§ñ **Claudio** [18:34:26]

Successfully wrote 25224 bytes to /home/neo/lightning-telegram-bot/locales/es.json

---
