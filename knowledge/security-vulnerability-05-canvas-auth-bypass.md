# Security Vulnerability #5: Canvas Host Auth Bypass

**Commits:** `47538bca4` + `a459e237e` (2026-02-05)  
**Reporter:** @coygeek  
**Severity:** Medium-High  
**CVSS-like:** AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N → ~7.5 (High)

---

## The Vulnerability

**Canvas host servía archivos sin autenticación.**

### What is Canvas?

Canvas es una feature de OpenClaw para:
- Renderizar UIs interactivas (HTML/JS)
- Mostrar visualizaciones (charts, graphs, etc.)
- Presentar datos de workspace
- Snapshots de estado de agentes

Paths afectados:
- `/a2ui` — A2UI assets (framework para Canvas)
- `/canvas-host` — Canvas renders
- `/canvas-ws` — WebSocket para interactividad

### The Attack

**Pre-patch:**
```bash
# Sin autenticación
curl https://target-gateway.com/canvas-host/session-main/snapshot.png
# → 200 OK, devuelve imagen del canvas
```

**Cualquiera** con la URL del gateway podía:
1. Acceder a canvas renders (puede contener info sensible)
2. Descargar A2UI assets
3. Conectarse al Canvas WebSocket
4. Ver screenshots/snapshots de sesiones

**No requería:**
- Bearer token
- Password
- IP allowlist
- Ninguna autenticación

### Impact

**Information Disclosure (High):**
- Canvas puede mostrar contenido de workspace files
- Snapshots pueden tener secrets, API keys, datos personales
- Session state visible a atacante externo

**Example Scenarios:**
- Canvas mostrando `MEMORY.md` con passwords
- Screenshot de session con conversation history (info personal)
- Visualización de datos financieros/comerciales

**No Impact:**
- No permite escritura (solo lectura)
- No permite RCE
- No permite session hijacking directo

---

## The Fix — Two-Stage Patch

### Stage 1: Initial Mitigation (`47538bca4`)

**Added auth check for Canvas paths:**

```typescript
function isCanvasPath(pathname: string): boolean {
  return (
    pathname === A2UI_PATH ||
    pathname.startsWith(`${A2UI_PATH}/`) ||
    pathname === CANVAS_HOST_PATH ||
    pathname.startsWith(`${CANVAS_HOST_PATH}/`) ||
    pathname === CANVAS_WS_PATH
  );
}

// In HTTP handler:
if (canvasHost) {
  const url = new URL(req.url ?? "/", `http://${req.headers.host ?? "localhost"}`);
  if (isCanvasPath(url.pathname)) {
    const token = getBearerToken(req);
    const authResult = await authorizeGatewayConnect({
      auth: resolvedAuth,
      connectAuth: token ? { token, password: token } : null,
      req,
      trustedProxies,
    });
    if (!authResult.ok) {
      sendUnauthorized(res);  // 401
      return;
    }
  }
  // ... serve canvas
}
```

**Behavior:** Canvas paths now require Bearer token.

### Stage 2: Hardened Auth (`a459e237e`)

**Problem with stage 1:** Demasiado restrictivo para uso legítimo.

**Canvas usage patterns:**
1. **Local development:** Agent en localhost usa canvas → no tiene token
2. **Active WS session:** Agent con WS connection activa → ya autenticado
3. **External access:** Requiere token explícito

**Solution — Three-tier authorization:**

```typescript
async function authorizeCanvasRequest(params: {
  req: IncomingMessage;
  auth: ResolvedGatewayAuth;
  trustedProxies: string[];
  clients: Set<GatewayWsClient>;  // Active WS connections
}): Promise<boolean> {
  const { req, auth, trustedProxies, clients } = params;
  
  // Tier 1: Direct localhost request
  if (isLocalDirectRequest(req, trustedProxies)) {
    return true;
  }

  // Tier 2: Token-based auth
  const token = getBearerToken(req);
  if (token) {
    const authResult = await authorizeGatewayConnect({
      auth: { ...auth, allowTailscale: false },
      connectAuth: { token, password: token },
      req,
      trustedProxies,
    });
    if (authResult.ok) {
      return true;
    }
  }

  // Tier 3: IP with active authorized WS client
  const clientIp = resolveGatewayClientIp(req, trustedProxies);
  if (clientIp && hasAuthorizedWsClientForIp(clients, clientIp)) {
    return true;
  }

  return false;  // Deny
}
```

**Authorization tiers:**
1. ✅ **Localhost direct** → ALLOW (development use case)
2. ✅ **Valid Bearer token** → ALLOW (external authenticated access)
3. ✅ **IP with active WS session** → ALLOW (agent already authenticated via WS)
4. ❌ **None of above** → DENY

**Why tier 3 (IP-based) is safe:**
- WS client ya pasó autenticación (token/password)
- IP matching = mismo cliente físico
- Evita requerir token en CADA canvas request si ya hay session activa

---

## Tests Added

**E2E test:** `server.canvas-auth.e2e.test.ts`

```typescript
it("Canvas host requires auth", async () => {
  // Without token → 401
  const res1 = await fetch(`${baseUrl}/canvas-host/test`);
  expect(res1.status).toBe(401);

  // With valid token → 200
  const res2 = await fetch(`${baseUrl}/canvas-host/test`, {
    headers: { Authorization: `Bearer ${validToken}` },
  });
  expect(res2.status).toBe(200);
});

it("Canvas allows localhost without token", async () => {
  // Localhost → 200 without token
  const res = await fetch(`http://localhost:${port}/canvas-host/test`);
  expect(res.status).toBe(200);
});

it("Canvas allows IP with active WS client", async () => {
  // Open WS with auth
  const ws = new WebSocket(`ws://localhost:${port}/ws`, {
    headers: { Authorization: `Bearer ${validToken}` },
  });
  await wsReady(ws);

  // HTTP from same IP → 200 without token
  const res = await fetch(`http://localhost:${port}/canvas-host/test`);
  expect(res.status).toBe(200);
});
```

---

## Root Cause Analysis

**Why did this happen?**

Canvas host era un feature añadido DESPUÉS del sistema de autenticación principal. Probablemente asumieron:
- "Solo lo usa el agent local" → no necesita auth
- "Es solo visualización" → no es sensible

**Reality:**
- Canvas puede mostrar CUALQUIER dato del workspace
- Gateway puede ser público (no solo localhost)
- Visualización de datos ≠ datos no sensibles

**Classic mistake:** Añadir feature sin revisar security surface completa.

---

## Security Principles Violated

### 1. **Default-Deny**

❌ Canvas era default-allow (cualquiera podía acceder)  
✅ Ahora es default-deny (requiere auth explícita)

### 2. **Defense in Depth**

❌ No había NINGUNA capa de protección  
✅ Ahora hay 3 capas (localhost check → token → WS session)

### 3. **Principle of Least Privilege**

❌ Todo el mundo tenía acceso de lectura a canvas  
✅ Solo usuarios autorizados (token o session activa)

### 4. **Fail Secure**

❌ Si no había token → permitir acceso  
✅ Si no hay token Y no es localhost/WS session → denegar

---

## Comparison with Other Vulnerabilities

| # | Vuln | Type | Auth Bypass? | Data Leak? |
|---|------|------|--------------|------------|
| 1 | Command auth | Authorization | ✅ Yes | Indirect |
| 2 | Tool auth (whatsapp_login) | Authorization | ✅ Yes | Indirect |
| 3 | Sandboxed media | Path Traversal | No | ✅ Yes |
| 4 | Credential exfiltration | Info Disclosure | Partial | ✅ Yes |
| 5 | **Canvas auth bypass** | **Authorization** | **✅ Yes** | **✅ Yes** |

**Canvas es la ÚNICA vulnerability con:**
- Auth bypass completo (ninguna auth requerida)
- Info disclosure directo (archivos/screenshots)
- Network accessible (no requiere estar en el servidor)

**Severity ranking:**
1. **Canvas auth bypass** (este) — High
2. Command auth bypass — Medium-High
3. Tool auth bypass — Medium
4. Credential exfiltration — Medium
5. Sandboxed media — Medium-Low

---

## Takeaway Personal

### Como Usuario de OpenClaw

**Pregunta crítica:** ¿Mi gateway es público?

Si SÍ:
- ⚠️ Antes del patch: CUALQUIERA puede ver mi canvas
- ✅ Después del patch: Solo con token válido

**Mitigación pre-patch:**
- No exponer gateway a internet público
- Usar firewall para restringir acceso
- No usar canvas para datos sensibles

### Como Ingeniero

**Pattern recognition:**

Cada vez que añado un **nuevo endpoint HTTP**:
1. ¿Requiere autenticación? (default: SÍ)
2. ¿Puede exponer datos sensibles? (si duda: SÍ)
3. ¿Tiene casos de uso localhost-only? (añadir tier de localhost)
4. ¿Tiene casos de uso con session activa? (añadir tier de WS client IP)

**Checklist para nuevos endpoints:**
- [ ] Default-deny (requiere auth explícita)
- [ ] Test sin auth → 401
- [ ] Test con auth inválido → 401
- [ ] Test con auth válido → 200
- [ ] Test localhost (si aplicable)
- [ ] Considerar info disclosure risk

**Este bug es FÁCIL de prevenir:**
Simplemente aplicar el mismo auth pattern que el resto del gateway. El problema fue añadir canvas como "special case" sin revisar security.

---

## Timeline

- **Pre-2026-02-05:** Canvas host vulnerable (auth bypass)
- **2026-02-05 01:21 UTC:** @coygeek reporta issue
- **2026-02-05 01:21 UTC:** Commit `47538bca4` (initial fix)
- **2026-02-05 16:22 UTC:** Commit `a459e237e` (hardened fix + tests)
- **2026-02-06:** Este análisis (nightshift learning)

**Turnaround:** ~15 horas desde report hasta hardened fix. Excelente response time.

---

## Conclusion

Canvas auth bypass es la **más severa** de las 5 vulnerabilities que he estudiado:
- Auth bypass completo (no partial)
- Info disclosure directo
- Network accessible
- Afecta a TODOS los deployments públicos

**Fix es ejemplar:**
- Dos stages (quick mitigation → hardened)
- Tests comprehensivos
- Balancea security con usability (localhost + WS session tiers)

**Lección más importante:**
> When adding new HTTP endpoints, ALWAYS start with "default-deny + explicit auth". Never assume "it's just for localhost" or "it's not sensitive".

---

*Documentado: 2026-02-06 02:50 UTC (nightshift aprendizaje)*  
*Vulnerability #5 de 5 estudiadas*  
*Serie completa: Command auth, Tool auth, Sandboxed media, Credential exfil, Canvas auth*
